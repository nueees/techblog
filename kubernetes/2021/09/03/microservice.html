<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Microservice | Cho’s Tech blog</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Microservice" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="8장-9장" />
<meta property="og:description" content="8장-9장" />
<link rel="canonical" href="https://nueees.github.io/techblog/kubernetes/2021/09/03/microservice.html" />
<meta property="og:url" content="https://nueees.github.io/techblog/kubernetes/2021/09/03/microservice.html" />
<meta property="og:site_name" content="Cho’s Tech blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-09-03T00:00:00-05:00" />
<script type="application/ld+json">
{"description":"8장-9장","url":"https://nueees.github.io/techblog/kubernetes/2021/09/03/microservice.html","@type":"BlogPosting","headline":"Microservice","dateModified":"2021-09-03T00:00:00-05:00","datePublished":"2021-09-03T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://nueees.github.io/techblog/kubernetes/2021/09/03/microservice.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/techblog/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://nueees.github.io/techblog/feed.xml" title="Cho's Tech blog" /><link rel="shortcut icon" type="image/x-icon" href="/techblog/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/techblog/">Cho&#39;s Tech blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/techblog/about/">About Me</a><a class="page-link" href="/techblog/gitInfo/">gitInfo</a><a class="page-link" href="/techblog/search/">Search</a><a class="page-link" href="/techblog/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Microservice</h1><p class="page-description">8장-9장</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2021-09-03T00:00:00-05:00" itemprop="datePublished">
        Sep 3, 2021
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      6 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/techblog/categories/#kubernetes">kubernetes</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>출처_Building Cloud private native 전문가 양성과정 교재 + 추가 MSA</p>

<h1 id="8-클라우드-서비스-소개">8. 클라우드 서비스 소개</h1>

<h2 id="81-클라우드-서비스-개요">8.1. 클라우드 서비스 개요</h2>

<ul>
  <li>네트워크를 이용해서 사용자들이 원하는 방식으로 서비스를 제공</li>
  <li>확장성</li>
  <li>사용 모델</li>
  <li>분산</li>
  <li>개인 시스템의 성능에 구애받지 않음</li>
</ul>

<h3 id="장점">장점</h3>

<ul>
  <li>초기 구성 비용 절감</li>
  <li>초기 구성 시간 절약</li>
  <li>확장성이</li>
</ul>

<h3 id="단점">단점</h3>

<ul>
  <li>오랜 기간 사용할 경우 비용 부담 증가</li>
</ul>

<h2><br /><br /></h2>
<h2 id="82-클라우드-서비스-분류">8.2. 클라우드 서비스 분류</h2>

<h3 id="saas-software-as-a-service-서비스로서-소프트웨어-애플리케이션-서비스를-제공">SaaS (Software as a Service): 서비스로서 소프트웨어 애플리케이션 서비스를 제공</h3>

<p>보통 IaaS, PaaS위에 올라가고, 중앙에서 호스팅되고 있는 소프트웨어를 웹 브라우저 같은 애플리케이션을 통해 사용<br />
ex) Google Docs</p>

<h3 id="paas-platform-as-a-service-서비스로서-플랫폼-소프트웨어를-제공">PaaS (Platform as a Service): 서비스로서 플랫폼 소프트웨어를 제공</h3>

<p>SaaS의 개념을 개발 플랫폼으로 확장한 방식<br />
플랫폼(OS)를 웹에서 쉽게 빌려 사용<br />
확장성과 경제적 이유로 On-Premise환경을 Cloud로 확장<br />
ex) Google APP Engine, OpenShift</p>

<h3 id="iaas-infrastructure-as-a-service서비스로서-인프라-자원-제공">IaaS (Infrastructure as a service):서비스로서 인프라 자원 제공</h3>

<p>Server, Storage, Network를 가상으로 만들어 사용자가 필요한 자원 사용<br />
관리와 책임이 클라우드 소비자에게 존재</p>

<p>ex) 대부분 퍼블릭 클라우드 서비스 (AWS EC2, S3)</p>

<h2 id="-1"><br /><br /></h2>
<h2 id="83-클라우드-서비스-종류">8.3. 클라우드 서비스 종류</h2>

<h3 id="private-cloud">Private Cloud</h3>

<p>자체적으로 데이터센터 안에 클라우드 환경 구축</p>

<ul>
  <li>자산 스스로 보유, 구축</li>
  <li>기존 IT 인프라 자원 활용 가능</li>
  <li>소규모로 구축할 때 비용이 높음</li>
  <li>보안 서비스를 자체적으로 구축해야 함</li>
</ul>

<h3 id="public-cloud">Public Cloud</h3>

<p>비용을 지불하고 서비스 제공 업체가 구축한 Server, Storage, Network 등 IT Infra 사용</p>

<ul>
  <li>공용 클라우드는 가입 형태의 서비스</li>
  <li>대규모 서비스로 구축 시 비용 절감</li>
  <li>서비스 제공자가 구축한 보안 서비스 안에서 운용</li>
</ul>

<h3 id="hybrid-cloud">Hybrid Cloud</h3>

<p>공용 + 사설 클라우드의 장점만 선택해서 사용</p>

<ul>
  <li>필요에 의해 데이터나 컴퓨팅 자원의 위치 조절</li>
  <li>데이터의 중요도와 비즈니스 핵심 업무 여부에 따라 선택 가능</li>
</ul>

<h2 id="-2"><br /><br /></h2>
<h1 id="9-microservice">9. Microservice</h1>

<h2 id="91-microservice-이해-및-구축-방법론">9.1 Microservice 이해 및 구축 방법론</h2>
<p>서비스를 비즈니스 경계에 맞게 세분화 하고, 서비스 간 통신은 네트워크 호출을 통해 진행하여 확장 가능하고 회복적이며 유연한 어플리케이션을 구성하는 것</p>

<h3 id="microservice-특징">Microservice 특징</h3>
<p>기존의 Monolithic 방식은 변화 대응이 어렵고, 새로운 기능 추가 및 업데이트가 어려움</p>
<ul>
  <li>서비스마다 필요한 기술 적용 (기술 이기종성)</li>
  <li>resource 낭비 줄임 (부분 scale out)</li>
  <li>
    <p>deploy/rollback 시 발생하는 risk 감소 (Blue-Green deploy로 점진적 변경)</p>
  </li>
  <li>Loosely Coupled: 장애 격리가 쉽고 신뢰도가 높음</li>
  <li>High Cohesion: Bounded_Context<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>라는 확실한 경계가 있고 구체적인 책임을 나눔</li>
</ul>

<p><strong>※ 시스템이 복잡하지 않을 경우, MSA 방식에서 요구되는 요소들이 오히려 생산성을 떨어뜨림</strong><br />
소스코드를 여러 라이브러리로 나누어서 유틸 생성하고 재사용
라이브러리를 통해 Java에 Module 컨셉을 부여해서 여러 버전의 모듈관리 (OSGI/Erlang)</p>

<h3 id="microservice-구성-전략">Microservice 구성 전략</h3>

<ul>
  <li>비즈니스 개념에 따른 모델링<br />
도메인 경계 정의, 기술보단 비즈니스 경계로, 서비스는 두고 DB 스키마부터 단계적 분리</li>
  <li>공통 자동화 문화 적용<br />
테스트 자동화 (CI<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>/CD<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>) 및 Custom Image 환경 구축</li>
</ul>

<h4 id="blue-green-배포">Blue-Green 배포</h4>
<p><img src="https://www.redhat.com/cms/managed-files/blue-green-deployment-model.gif" alt="blue-green-deployment" /><br />
Blue: 이전 버전<br />
Green: 신규 버전</p>

<h4 id="canaria-배포">Canaria 배포</h4>
<p><img src="https://user-images.githubusercontent.com/83441376/139980171-e44febeb-1bee-4047-804d-79f8ebe2fd9e.png" alt="canary-deployment" /></p>

<p><a href="https://harness.io/blog/blue-green-canary-deployment-strategies">배포관련 참고</a></p>

<h2 id="-3"><br /><br /></h2>
<h2 id="92-spring-cloud를-활용한-microservices-개발">9.2 Spring Cloud를 활용한 Microservices 개발</h2>

<h3 id="spring-cloud">Spring Cloud</h3>
<p>Spring Cloud는 Microservce Architecture 환경에서의 개발과 배포, 운영을 쉽게 구성할 수있도록 지원하는 Spring Boot 기반의 Framework<br />
Cloud Native한 패턴과 메커니즘을 제공 <br />
많은 서비스들이 Java 기반의 Spring Boot로 개발되기에, Java 기반 MSA를 구축하고자 할 시 최적의 선택</p>

<h4 id="spring-boot">Spring Boot</h4>
<p>기존 Spring 이 가지고 있던 문제들을 해결하여, 보다 빠르게 상용 Spring Application을 개발하고자 시작<br />
Conventioin over Configuration (설정보다 관례)</p>
<ul>
  <li>Library 관리 자동화 (Starter 이용)</li>
  <li>자동 environment configuration (Annotaion 이용)</li>
  <li>내장 Tomcat 및 JAR 모델 지원 ( Web Application이어도 JAR로 packaging runtime 지원)</li>
</ul>

<h4 id="annotaion">Annotaion</h4>
<p>마치 코드의 메타데이터 같은 역할을 하여, Compile, Runtime 과정에서 코드를 어떻게 처리할 것인지 나타냄<br />
Annotation을 통해 Spring Boot가 지향하는 Convention over Configuration을 가능하게 함</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@SpringBootApplication
public class TestApplication {
  public static void main (String[] args) {
    SpringApplicatoin.run(MyApplication.class, args);
  }
}
</code></pre></div></div>

<h3 id="msa-architecture">MSA architecture</h3>
<p><a href="https://www.nginx.com/blog/introduction-to-microservices/">MSA architecture 참고 링크</a></p>

<h3 id="msa-component">MSA component</h3>

<p>1) Edge Server (API Gateway): Zuul/Ribbon, Spring Cloud GW<br />
<img src="https://user-images.githubusercontent.com/83441376/140001251-f2111415-a76d-42ac-a2cc-fced85968fc9.png" alt="image" /><br />
모든 클라이언트 요청에 대한 end point를 통합하는 서버(프록시 서버처럼 동작)<br />
한 서비스에 한개 이상의 서버가 존재하기 때문에 이 서비스를 사용하는 클라이언트 입장에서는 다수의 end point가 생기게 되며, 
end point를 변경이 일어났을때, 관리하기가 힘들다.<br />
이런 문제를 해결하기 위해 서비스들의 end point를 하나로 묶을 수 있는 API 게이트웨이가 필요<br />
각 서비스를 직접 호출하지않고 모든 요청이 API 게이트웨이를 통하게 만드는 것<br />
하나의 요청에 여러 서비스를 호출한 후 하나의 결과로 취합</p>

<p>요청에 따라 필요한 서비스로 라우팅<br />
모든 서비스의 API 를 노출하는 대신 필요한 API 만을 노출해서 캡슐화<br />
클라이언트 별로 다른 API 를 제공<br />
하나의 요청에 필요한 서비스를 각각 호출해 결과를 모아서 응답<br />
내부에서 사용하는 프로토콜이 다를 경우 외부에는 웹 친화적인 프로토콜(HTTP, WebSocket 등)으로 변환<br />
클라이언트와의 통신을 줄일 수 있고, 클라이언트의 코드도 단순<br />
인증 및 권한, 모니터링, load balancing, caching, logging 등 추가적인 기능</p>

<p>하나의 엔트리 포인트를 갖는 것은 장점이자 단점</p>

<p>API 게이트웨이에서 하는 역할이 많고, 게이트웨이에 장애가 나면 서비스 전체가 사용이 불가능 -&gt; circuit breaker<br />
각 서비스의 API 를 수정하면 API 게이트웨이를 함께 수정해야 합니다. 이는 개발 과정에서 병목(bottleneck)이 되어 개발 과정 지연<br />
API 게이트웨이 또한 개발하고 유지보수해야 할 대상</p>

<p>2) Load Balancer: Ribbon</p>
<ul>
  <li>ServerList: 로드 밸런싱 대상 서버 목록<br />
configuration을 통해 static 하게 설정 가능<br />
eureka 등을 기반으로 dynamic하게 설정 가능</li>
  <li>Rule: 요청을 보낼 서버를 선택<br />
Round Robbin - 한 서버씩 돌아가며 전달<br />
Available Filtering - 에러가 많은 서버 제외<br />
weighted Response Time - 서버별 응답 시간에 따라 확률 조절</li>
  <li>Ping: 서버list가 살아있는지 체크<br />
static, dynamic 모두 가능</li>
</ul>

<p>3) Service Discovery (Service Registry): Eureka, Spring Cloud LB <br />
<img src="https://user-images.githubusercontent.com/83441376/140001039-1e4c6908-fcfc-4b68-b2ba-effbf77107d8.png" alt="image" /></p>

<p>클라우드에서 인스턴스는 동적으로 할당되기 때문에 IP주소나 포트 정보가 정해지지 않은 데다가 오토스케일링도 일어나고 중지되고 복구되면서 네트워크 위치가 계속해서 바뀌게 됩니다.</p>

<p>따라서 클라이언트나 API 게이트웨이가 호출할 서비스를 찾는 매커니즘이 필요하고 이를 서비스 디스커버리(Service Discovery)라고 합니다. 이러한 로직을 구현하는 쪽에 따라서 두 가지 방식으로 나뉩니다.</p>

<ul>
  <li>클라이언트 사이드 디스커버리 패턴(Client-Side Discovery Pattern)</li>
  <li>서버 사이드 디스커버리 패턴(Server-Side Discovery Pattern)</li>
</ul>

<p>API 게이트웨이는 각 서비스를 호출하기 위해 IP 주소와 포트를 알고 있어야 합니다. 기존 환경에서는 이러한 서버의 위치가 고정이라 문제가 없지만, 클라우드 기반에서는 각 서비스가 동적으로 할당된 서버에 배포되면서 해당 서비스의 위치를 파악하는 것이 어려워졌습니다. 이렇게 해당 서비스의 위치를 찾는 기술을 서비스 디스커버리(Service Discovery)라고 합니다. API 게이트웨이는 서버 사이드, 혹은 클라이언트 사이드 기준으로 서비스 디스커버리를 구현할 수 있습니다.</p>

<p>4) Circuit Breaker: Hystrix, Resilence4j</p>
<ul>
  <li>회로 차단기 (Circuit Breaker)<br />
이름 그대로 전기선에 유입된 과전류를 감지하는데 이와 마찬가지로 하위 컴포넌트가 과전류에 손상되지 않도록 보호<br />
원격 자원에 대한 모든 호출을 모니터링하고 임계점까지 실패한다면 회로 차단기가 활성화 되어 빠른 실패를 유도, 그리고 문제가 있는 원격 자원을 더 이상 호출하지 못하게 함</li>
  <li>폴백 (Fallback)<br />
원격 서비스에 대한 호출이 실패할 때, 대체 코드(fallback method)를 실행</li>
  <li>벌크헤드 (Bulkhead)<br />
서비스에 대한 동시 요청 수를 제한<br />
원격 자원에 대한 호출을 자원 별 스레드 풀로 분리<br />
특정 원격 자원 호출이 느려지더라도 다른 자원들에 대한 호출은 영향이 없음</li>
</ul>

<p>5) Config Server: Spring Cloud Config Server<br />
Spring Cloud Config는 분산 시스템에서 환경설정을 외부로 분리하여 중앙에서 관리할 수 있는 기능을 제공<br />
Application data(환경별 구성 데이터)를 microservice와 분리<br />
따라서 마이크로서비스 인스턴스가 아무리 많더라도 항상 동일한 구성을 유지할 수 있음<br />
Spring Cloud Config에는 고유한 관리 저장소가 있지만 아래의 오픈 소스 프로젝트와도 통합할 수 있음</p>

<ul>
  <li>
    <p>Spring Config Server : 공통 환경설정을 가지고 있는 Config Cloud Server
환경설정(name-value pair, YAML 파일)을 위한 HTTP, 리소스 기반 API
속성 값 암호화 및 암호 해독 (대칭 또는 비대칭)
\@EnableConfigServer 어노테이션을 사용하여 쉽게 Spring Boot 어플케이션에 적용</p>
  </li>
  <li>
    <p>Spring Config Client : 공통 환경설정을 받아 사용하는 Application Server
Config Server에 붙어 원격 속성 소스로 Spring 환경 초기화
속성 값 암호화 및 암호 해독 (대칭 또는 비대칭)</p>
  </li>
</ul>

<p>6) Message Stream: RabbitMQ, Kafka<br />
Spring cloud bus: 동적으로 config 변경을 적용하기 위한 MOM<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup>을 구성한 MQ(Message Queue) Handler</p>

<p>(1) MQ(Message Queue)에 Publisher(=config server)와 Subscriber(마이크로서비스)를 등록<br />
(2) config 변경 정보를 MQ에 전송(Publish Message)<br />
(3) 각 마이크로서비스에서 config 동적 반영(Reload Config)</p>

<p>7) Monitoring: Zipkin</p>

<h2 id="-4"><br /><br /></h2>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>내부는 독립적으로 차단되고 외부와 연결하려면 interface를 통해서 소통 가능 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>자동화된 빌드 및 테스트가 수행된 후, 개발자가 코드 변경을 repository에 정기적으로 병합하는 개발 방식 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>코드 변경 사항을 repository에서 고객이 사용 가능한 production 환경까지 자동으로 release하는 개발 방식 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>분산 시스템 환경에서 독립된 서비스 간에 비동기 방식으로 메세지를 전송/수신할 수 있게 도와주는 인프라 <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div><a class="u-url" href="/techblog/kubernetes/2021/09/03/microservice.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/techblog/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/techblog/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/techblog/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>A challenge-loving junior data engineer.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/nueees" title="nueees"><svg class="svg-icon grey"><use xlink:href="/techblog/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/nueees" title="nueees"><svg class="svg-icon grey"><use xlink:href="/techblog/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
