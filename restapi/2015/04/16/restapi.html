<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>REST API &amp; OAuth | Cho’s Tech blog</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="REST API &amp; OAuth" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="section4" />
<meta property="og:description" content="section4" />
<link rel="canonical" href="https://nueees.github.io/techblog/restapi/2015/04/16/restapi.html" />
<meta property="og:url" content="https://nueees.github.io/techblog/restapi/2015/04/16/restapi.html" />
<meta property="og:site_name" content="Cho’s Tech blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-04-16T00:00:00-05:00" />
<script type="application/ld+json">
{"datePublished":"2015-04-16T00:00:00-05:00","url":"https://nueees.github.io/techblog/restapi/2015/04/16/restapi.html","@type":"BlogPosting","dateModified":"2015-04-16T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://nueees.github.io/techblog/restapi/2015/04/16/restapi.html"},"headline":"REST API &amp; OAuth","description":"section4","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/techblog/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://nueees.github.io/techblog/feed.xml" title="Cho's Tech blog" /><link rel="shortcut icon" type="image/x-icon" href="/techblog/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/techblog/">Cho&#39;s Tech blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/techblog/about/">About Me</a><a class="page-link" href="/techblog/gitInfo/">gitInfo</a><a class="page-link" href="/techblog/search/">Search</a><a class="page-link" href="/techblog/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">REST API &amp; OAuth</h1><p class="page-description">section4</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2015-04-16T00:00:00-05:00" itemprop="datePublished">
        Apr 16, 2015
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      7 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/techblog/categories/#restapi">restapi</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h1"><a href="#4-rest-api">4. REST API</a>
<ul>
<li class="toc-entry toc-h3"><a href="#rest-api의-설계-가이드">REST API의 설계 가이드</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#41-rest-api-제약사항">4.1. REST API 제약사항</a>
<ul>
<li class="toc-entry toc-h2"><a href="#client-server">Client-Server</a></li>
<li class="toc-entry toc-h2"><a href="#stateless">Stateless</a></li>
<li class="toc-entry toc-h2"><a href="#cacheable">Cacheable</a></li>
<li class="toc-entry toc-h2"><a href="#uniform-interface">Uniform Interface</a>
<ul>
<li class="toc-entry toc-h3"><a href="#identification-of-resources-resource가-uri로-식별되면-된다">identification of resources: Resource가 URI로 식별되면 된다</a></li>
<li class="toc-entry toc-h3"><a href="#manipulation-of-resources-through-representations-representations-전송을-통해서-resources를-조작해야-한다">manipulation of resources through representations: representations 전송을 통해서 resources를 조작해야 한다</a></li>
<li class="toc-entry toc-h3"><a href="#self-descriptive-messages-메시지-만으로-어떤-메시지-인지-알-수-있어야-한다">self-descriptive messages: 메시지 만으로 어떤 메시지 인지 알 수 있어야 한다</a></li>
<li class="toc-entry toc-h3"><a href="#hypermedia-as-the-engine-of-application-state-애플리케이션의-상태는-hyperlink를-이용해-전이되어야한다-페이지-변경-등">Hypermedia As The Engine Of Application State: 애플리케이션의 상태는 Hyperlink를 이용해 전이되어야한다. (페이지 변경 등)</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#layered-system">Layered System</a></li>
<li class="toc-entry toc-h2"><a href="#code-on-demand-optional">Code on demand (optional)</a></li>
<li class="toc-entry toc-h2"><a href="#"></a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#5-oauth-20">5. OAuth 2.0</a>
<ul>
<li class="toc-entry toc-h3"><a href="#authenticationauthn-인증-who-are-you">Authentication(AuthN) 인증: Who are you?</a></li>
<li class="toc-entry toc-h3"><a href="#authorizationauthz-권한-what-can-you-do">Authorization(AuthZ) 권한: What can you do?</a></li>
<li class="toc-entry toc-h2"><a href="#51-oauth-20-인증">5.1. OAuth 2.0 인증</a>
<ul>
<li class="toc-entry toc-h3"><a href="#resource-owner-사용자">Resource owner: 사용자</a></li>
<li class="toc-entry toc-h3"><a href="#client-resource-server-에서-제공하는-자원을-사용하는-애플리케이션-예-페이스북의-뉴스를-모아서-보여주는-앱">Client: Resource Server 에서 제공하는 자원을 사용하는 애플리케이션 (예, 페이스북의 뉴스를 모아서 보여주는 앱)</a></li>
<li class="toc-entry toc-h3"><a href="#resource-serverapi-server-자원을-호스팅하는-서버-예-페이스북-사진-비디오-등">Resource server(API server): 자원을 호스팅하는 서버, (예, 페이스북 사진 비디오 등)</a></li>
<li class="toc-entry toc-h3"><a href="#authorization-server-사용자의-동의를-받아서-권한을-부여하는-서버-일반적으로-resource-server-와-같은-url-하위에-있는-경우가-많음">Authorization Server: 사용자의 동의를 받아서 권한을 부여하는 서버, 일반적으로 Resource Server 와 같은 URL 하위에 있는 경우가 많음</a></li>
<li class="toc-entry toc-h3"><a href="#oauth-인증과정">OAuth 인증과정</a></li>
<li class="toc-entry toc-h3"><a href="#서버-쪽-요청-보내는-쿼리-파라메터">서버 쪽 요청 보내는 쿼리 파라메터</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#52-oauth-20의-인증종류">5.2. OAuth 2.0의 인증종류</a>
<ul>
<li class="toc-entry toc-h3"><a href="#authorization-code-grant">Authorization Code Grant</a></li>
<li class="toc-entry toc-h3"><a href="#implicit-grant">Implicit Grant</a></li>
<li class="toc-entry toc-h3"><a href="#password-credentials-grant">Password Credentials Grant</a></li>
<li class="toc-entry toc-h3"><a href="#client-credentials-grant">Client Credentials Grant</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#53-token">5.3. Token</a>
<ul>
<li class="toc-entry toc-h3"><a href="#access-token">Access Token</a></li>
<li class="toc-entry toc-h3"><a href="#refresh-token">Refresh Token</a></li>
<li class="toc-entry toc-h3"><a href="#토큰의-갱신-과정">토큰의 갱신 과정</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#54-openid-connect">5.4. OpenID Connect</a></li>
<li class="toc-entry toc-h2"><a href="#-1"></a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#6-ssl-certification">6. SSL Certification</a>
<ul>
<li class="toc-entry toc-h2"><a href="#61-대칭키">6.1. 대칭키</a></li>
<li class="toc-entry toc-h2"><a href="#-2"></a></li>
<li class="toc-entry toc-h2"><a href="#62-공개키">6.2. 공개키</a></li>
<li class="toc-entry toc-h2"><a href="#-3"></a></li>
<li class="toc-entry toc-h2"><a href="#63-ssl-인증">6.3. SSL 인증</a>
<ul>
<li class="toc-entry toc-h4"><a href="#ssh에-key-pair-추가">ssh에 key pair 추가</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#-4"></a></li>
<li class="toc-entry toc-h2"><a href="#64-ssl-통신">6.4. SSL 통신</a></li>
<li class="toc-entry toc-h2"><a href="#-5"></a></li>
</ul>
</li>
</ul><p>📎 Coding Everybody</p>

<hr>

<h1 id="4-rest-api">
<a class="anchor" href="#4-rest-api" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. <a href="https://velog.io/@taeha7b/api-restapi-restfulapi">REST API</a>
</h1>
<p>REST API(REpresentational State Transfer)는 웹상에서 사용되는 여러 리소스를 HTTP URI로 표현하고, 해당 리소스에 대한 행위를 HTTP Method로 정의하는 방식<br>
리소스(HTTP URI로 정의됨)를 어떻게 하겠다(HTTP Method + Payload)를 구조적으로 깔끔하게 표현하는 방법</p>

<h3 id="rest-api의-설계-가이드">
<a class="anchor" href="#rest-api%EC%9D%98-%EC%84%A4%EA%B3%84-%EA%B0%80%EC%9D%B4%EB%93%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a>REST API의 설계 가이드</h3>
<p>리소스에 대한 행위는 HTTP Method(POST, GET, PUT, DELETE)로 표현해야 합니다.<br>
/(슬래시)는 계층 관계를 나타낼때 사용합니다.<br>
URI 마지막 문자에 /(슬래시)를 사용하지 않습니다.<br>
URI에 _(underscore)는 사용하지 않도록 합니다. 또한 영어 대문자보다는 소문자를 씁니다. 그리고 가독성을 위해서 긴 단어는 잘 사용하지 않습니다.<br>
URI에 동사는 GET, POST와 같은 HTTP Method를 표현하기 때문이다.<br>
동사가 아니라 명사를 사용한다.<br>
URI에 파일의 확장자(예를들어 .json , .JPGE)를 포함 시키지 않습니다.</p>

<h1 id="41-rest-api-제약사항">
<a class="anchor" href="#41-rest-api-%EC%A0%9C%EC%95%BD%EC%82%AC%ED%95%AD" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.1. <a href="https://sabarada.tistory.com/26">REST API 제약사항</a>
</h1>

<h2 id="client-server">
<a class="anchor" href="#client-server" aria-hidden="true"><span class="octicon octicon-link"></span></a>Client-Server</h2>
<p>사용자들에게 제공하는 interface인 User Interface와 데이터 스토리지, 알고리즘 등 서버 내부의 작업들을 분리함으로 써 User Interface는 여러 플랫폼에서의 이식성을 향상될 수 있으며, 서버는 그 구성요소를 단순화하여 확장성을 단순화할 수 있습니다.<br>
클라이언트와 서버가 서로 의존하지 않고 별도로 진화할 수 있습니다. 클라이언트는 서버의 리소스 URI만 알고 있으면 되기 때문입니다.</p>

<h2 id="stateless">
<a class="anchor" href="#stateless" aria-hidden="true"><span class="octicon octicon-link"></span></a>Stateless</h2>
<p>클라이언트에서 서버로의 각 요청에는 그 요청을 이해하는 데 필요한 모든 정보가 포함되어야 합니다. 서버에 저장된 환경 정보를 이용해서 이득(서버에서의 클라이언트 정보 유지 등)을 취하면 안 됩니다. 따라서 세션의 정보는 전적으로 클라이언트가 가지고 있어야 합니다.<br>
로그인했다는 세션 유지가 필요하다면 그 정보 또한 Client가 해당 정보를 가지고 서버에 전달해야 한다. e.g. JWT 등을 사용</p>

<h2 id="cacheable">
<a class="anchor" href="#cacheable" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cacheable</h2>
<p>요청에 대한 응답 내의 데이터에 해당 요청은 캐시가 가능한지 불가능 한지 명시해야 합니다. 응답을 캐시 할 수 있다면 클라이언트에서 동일한 요청이 왔을 때 응답 데이터를 재사용할 수 있어야 합니다.<br>
cache-control 헤더를 통하여 캐시 여부 명시</p>

<h2 id="uniform-interface">
<a class="anchor" href="#uniform-interface" aria-hidden="true"><span class="octicon octicon-link"></span></a>Uniform Interface</h2>
<p>전체적인 시스템 아키텍처를 간단하고 잘 파악할 수 있도록 하기 위한 약속된 Interface, 해당 규약을 REST를 사용자들이 지킴으로써 추후에 사용하는 Client를 개발하는 사용자와 Server를 개발하는 사용자 간의 결합도가 낮아질 수 있다(Decoupling). 개발 <a href="https://sabarada.tistory.com/9">REST는 규약으로 4가지</a> 를 제시합니다.</p>

<h3 id="identification-of-resources-resource가-uri로-식별되면-된다">
<a class="anchor" href="#identification-of-resources-resource%EA%B0%80-uri%EB%A1%9C-%EC%8B%9D%EB%B3%84%EB%90%98%EB%A9%B4-%EB%90%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>identification of resources: Resource가 URI로 식별되면 된다</h3>

<h3 id="manipulation-of-resources-through-representations-representations-전송을-통해서-resources를-조작해야-한다">
<a class="anchor" href="#manipulation-of-resources-through-representations-representations-%EC%A0%84%EC%86%A1%EC%9D%84-%ED%86%B5%ED%95%B4%EC%84%9C-resources%EB%A5%BC-%EC%A1%B0%EC%9E%91%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>manipulation of resources through representations: representations 전송을 통해서 resources를 조작해야 한다</h3>
<p>Representations: HTTP 메소드의 PUT, GET, DELTE 등을 말한다.</p>

<h3 id="self-descriptive-messages-메시지-만으로-어떤-메시지-인지-알-수-있어야-한다">
<a class="anchor" href="#self-descriptive-messages-%EB%A9%94%EC%8B%9C%EC%A7%80-%EB%A7%8C%EC%9C%BC%EB%A1%9C-%EC%96%B4%EB%96%A4-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%9D%B8%EC%A7%80-%EC%95%8C-%EC%88%98-%EC%9E%88%EC%96%B4%EC%95%BC-%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>self-descriptive messages: 메시지 만으로 어떤 메시지 인지 알 수 있어야 한다</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Client]
GET / HTTP/1.1
Host: www.example.org

Server]
HTTP/1.1 200 OK
Content-Type: application/json-patch+json
\[{ “op” : “remove”, “path” : “a/b/c"}\]
</code></pre></div></div>

<h3 id="hypermedia-as-the-engine-of-application-state-애플리케이션의-상태는-hyperlink를-이용해-전이되어야한다-페이지-변경-등">
<a class="anchor" href="#hypermedia-as-the-engine-of-application-state-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%98-%EC%83%81%ED%83%9C%EB%8A%94-hyperlink%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-%EC%A0%84%EC%9D%B4%EB%90%98%EC%96%B4%EC%95%BC%ED%95%9C%EB%8B%A4-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B3%80%EA%B2%BD-%EB%93%B1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hypermedia As The Engine Of Application State: 애플리케이션의 상태는 Hyperlink를 이용해 전이되어야한다. (페이지 변경 등)</h3>
<p>어디서 어디로 전이가 가능한지 미리 결정되지 않는다. 어떤 상태로 전이가 완료되고 나서야 그 다음 전이 될 수 있는 상태가 결정된다. 링크가 동적으로 변경될 수 있음</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 200 OK
Content-Type: application/json
Link: &lt;/articles/1&gt;; rel=“previous”,
      &lt;/articles/3&gt;; rel=“next”;
{
    “Title” : “The second article”,
    “content” : “Hello! Brother"
}
</code></pre></div></div>

<h2 id="layered-system">
<a class="anchor" href="#layered-system" aria-hidden="true"><span class="octicon octicon-link"></span></a>Layered System</h2>
<p>계층화된 시스템 아키텍처를 사용하여 각 구성들 간의 계층을 마음대로 상호작용 할 수 없도록 제한 함으로 써 Interface를 일원화할 수 있습니다.</p>

<h2 id="code-on-demand-optional">
<a class="anchor" href="#code-on-demand-optional" aria-hidden="true"><span class="octicon octicon-link"></span></a>Code on demand (optional)</h2>
<p>서버가 네트워크를 통해 클라이언트에 전달한 javascript 등과 같은 프로그램들은 그 자체로 실행이 될 수 있어야 한다. 이것은 사전 구현에 필요한 기능의 수를 줄임으로써 클라이언트를 단순화합니다.<br>
이 말은 우리가 평소에는 정적인 데이터를 xml 또는 json에 담아서 client로 보내고 client가 이것을 가공합니다. 하지만 code on demand라는 것은 client에 보내는 데이터를 바로 실행 가능한 코드를 보내서 이것을 Client에서 실행하는 것을 말합니다.</p>

<h2>
<a class="anchor" href="#" aria-hidden="true"><span class="octicon octicon-link"></span></a><br><br>
</h2>

<h1 id="5-oauth-20">
<a class="anchor" href="#5-oauth-20" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. <a href="https://velog.io/@jakeseo_me/Oauth-2.0%EA%B3%BC-OpenID-Connect-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%A0%95%EB%A6%AC">OAuth 2.0</a>
</h1>
<p>OAuth 2.0은 다양한 플랫폼 환경에서 인증과 권한 부여를 위한 산업 표준 프로토콜</p>

<h3 id="authenticationauthn-인증-who-are-you">
<a class="anchor" href="#authenticationauthn-%EC%9D%B8%EC%A6%9D-who-are-you" aria-hidden="true"><span class="octicon octicon-link"></span></a>Authentication(AuthN) 인증: Who are you?</h3>
<p>시스템 접근을 확인하는 것 (로그인) -&gt; 인증만 하는 것은 openID</p>
<h3 id="authorizationauthz-권한-what-can-you-do">
<a class="anchor" href="#authorizationauthz-%EA%B6%8C%ED%95%9C-what-can-you-do" aria-hidden="true"><span class="octicon octicon-link"></span></a>Authorization(AuthZ) 권한: What can you do?</h3>
<p>행위의 권리를 검증하는 것 (Delegated Authorization) -&gt; OAuth 2.0</p>

<h2 id="51-oauth-20-인증">
<a class="anchor" href="#51-oauth-20-%EC%9D%B8%EC%A6%9D" aria-hidden="true"><span class="octicon octicon-link"></span></a>5.1. OAuth 2.0 인증</h2>

<h3 id="resource-owner-사용자">
<a class="anchor" href="#resource-owner-%EC%82%AC%EC%9A%A9%EC%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>Resource owner: 사용자</h3>
<h3 id="client-resource-server-에서-제공하는-자원을-사용하는-애플리케이션-예-페이스북의-뉴스를-모아서-보여주는-앱">
<a class="anchor" href="#client-resource-server-%EC%97%90%EC%84%9C-%EC%A0%9C%EA%B3%B5%ED%95%98%EB%8A%94-%EC%9E%90%EC%9B%90%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%98%88-%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%B6%81%EC%9D%98-%EB%89%B4%EC%8A%A4%EB%A5%BC-%EB%AA%A8%EC%95%84%EC%84%9C-%EB%B3%B4%EC%97%AC%EC%A3%BC%EB%8A%94-%EC%95%B1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Client: Resource Server 에서 제공하는 자원을 사용하는 애플리케이션 (예, 페이스북의 뉴스를 모아서 보여주는 앱)</h3>
<h3 id="resource-serverapi-server-자원을-호스팅하는-서버-예-페이스북-사진-비디오-등">
<a class="anchor" href="#resource-serverapi-server-%EC%9E%90%EC%9B%90%EC%9D%84-%ED%98%B8%EC%8A%A4%ED%8C%85%ED%95%98%EB%8A%94-%EC%84%9C%EB%B2%84-%EC%98%88-%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%B6%81-%EC%82%AC%EC%A7%84-%EB%B9%84%EB%94%94%EC%98%A4-%EB%93%B1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Resource server(API server): 자원을 호스팅하는 서버, (예, 페이스북 사진 비디오 등)</h3>
<h3 id="authorization-server-사용자의-동의를-받아서-권한을-부여하는-서버-일반적으로-resource-server-와-같은-url-하위에-있는-경우가-많음">
<a class="anchor" href="#authorization-server-%EC%82%AC%EC%9A%A9%EC%9E%90%EC%9D%98-%EB%8F%99%EC%9D%98%EB%A5%BC-%EB%B0%9B%EC%95%84%EC%84%9C-%EA%B6%8C%ED%95%9C%EC%9D%84-%EB%B6%80%EC%97%AC%ED%95%98%EB%8A%94-%EC%84%9C%EB%B2%84-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9C%BC%EB%A1%9C-resource-server-%EC%99%80-%EA%B0%99%EC%9D%80-url-%ED%95%98%EC%9C%84%EC%97%90-%EC%9E%88%EB%8A%94-%EA%B2%BD%EC%9A%B0%EA%B0%80-%EB%A7%8E%EC%9D%8C" aria-hidden="true"><span class="octicon octicon-link"></span></a>Authorization Server: 사용자의 동의를 받아서 권한을 부여하는 서버, 일반적으로 Resource Server 와 같은 URL 하위에 있는 경우가 많음</h3>

<h3 id="oauth-인증과정">
<a class="anchor" href="#oauth-%EC%9D%B8%EC%A6%9D%EA%B3%BC%EC%A0%95" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://showerbugs.github.io/2017-11-16/OAuth-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C">OAuth 인증과정</a>
</h3>
<p><img src="https://user-images.githubusercontent.com/83441376/170871622-3ffeb1f8-cd75-4eea-9a0d-bf493a350633.png" alt="image">
발급받은 Access Token은 서비스에서 자체적으로 저장, 관리</p>

<h3 id="서버-쪽-요청-보내는-쿼리-파라메터">
<a class="anchor" href="#%EC%84%9C%EB%B2%84-%EC%AA%BD-%EC%9A%94%EC%B2%AD-%EB%B3%B4%EB%82%B4%EB%8A%94-%EC%BF%BC%EB%A6%AC-%ED%8C%8C%EB%9D%BC%EB%A9%94%ED%84%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>서버 쪽 요청 보내는 쿼리 파라메터</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://accounts.google.com/o/oauth2/v2/auth?
response_type=code&amp;
client_id=your_client_id&amp;
scope=profile%20contacts&amp;
redirect_uri=https%3A//oauth2.example.com/code
</code></pre></div></div>
<ul>
  <li>response_type : 우리가 권한부여 서버로부터 받길 원하는 응답의 타입이다.</li>
  <li>scope : 클라이언트가 접근하길 원하는 리스트의 스코프이다. 이 리스트는 동의를 구하는 화면을 만들 때 권한부여 서버에 의해 사용된다.</li>
  <li>client_id : 클라이언트에 OAuth 세팅을 할 때, 권한부여 서버에 의해 제공된다. 이 ID는 권한 부여 서버가 OAuth 플로우를 시행하려는 클라이언트가 누구인지 알아내기 위해 사용된다.</li>
  <li>redirect_url : 권한부여 서버에게 OAuth 플로우가 끝나면 어디로 보내줄지에 대해 알려주는 역할이다.</li>
  <li>client_secret : 권한부여 서버에 의해 제공된다. OAuth 플로우에서 이 파라미터는 필수 옵션은 아니다. 권한부여 코드 플로우에서 이 client_secret의 중요성에 대해 알아볼 것이다.</li>
</ul>

<h2 id="52-oauth-20의-인증종류">
<a class="anchor" href="#52-oauth-20%EC%9D%98-%EC%9D%B8%EC%A6%9D%EC%A2%85%EB%A5%98" aria-hidden="true"><span class="octicon octicon-link"></span></a>5.2. OAuth 2.0의 인증종류</h2>
<p>||Confidential Client|Public Client|
|:–:|:–:|:–:|
|3-legged|Authorization Code|Implicit|
|2-legged|Resource Owner Password Credentials|Client Credentials|</p>

<h3 id="authorization-code-grant">
<a class="anchor" href="#authorization-code-grant" aria-hidden="true"><span class="octicon octicon-link"></span></a>Authorization Code Grant</h3>
<p>서버사이드 코드로 인증하는 방식<br>
권한서버가 클라이언트와 리소스 서버간의 중재역할<br>
access token을 바로 클라이언트로 전달하지 않아 잠재적 유출을 방지<br>
로그인시에 페이지 URL에 response_type=code 라고 넘긴다</p>

<p>브라우저에서 access token 노출을 방지하기 위해서, 클라이언트의 프론트엔드 채널은 권한 부여 서버로부터 application code를 얻는다. 그리고 application code를 백엔드 채널로 보낸다. application code를 access token으로 바꾸기 위해서, client_secret이 필요하다. client_secret은 클라이언트의 백엔드 채널에 의해서만 알려지게 되며, 프론트엔드 채널은 client_secret에 관여하지 않는다. 백엔드 채널은 POST 요청을 권한부여 서버에 application code와 client_secret을 동봉해서 보낸다. 요청은 다음과 같이 보내진다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /token HTTP/1.1
Host: oauth2.googleapis.com
Content-Type: application/x-www-form-urlencoded
code=4/W7q7P51a-iMsCeLvIaQc6bYrgtp9&amp;
client_id=your_client_id&amp;
client_secret==your_client_secret_only_known_by_server&amp;
redirect_url=https%3A//oauth2.example.com/code
</code></pre></div></div>

<p>권한 부여 서버는 client_secret과 application code의 유효성을 검사하고 access token을 보내준다. 백엔드 채널은 access token을 갖고 있고 이 토큰을 리소스 서버에서 정보를 갖고올 때 사용한다. 이러한 방법으로 브라우저는 access token에 접근하지 않는 방식으로 구현할 수 있다.</p>

<h3 id="implicit-grant">
<a class="anchor" href="#implicit-grant" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implicit Grant</h3>
<p><img src="https://user-images.githubusercontent.com/83441376/170872224-3a7739f7-7f74-430c-b1b6-0474e89e1035.png" alt="image"></p>

<p>token과 scope에 대한 스펙 등은 다르지만 OAuth 1.0a과 가장 비슷한 인증방식<br>
Public Client인 브라우저 기반의 어플리케이션(Javascript application)이나 모바일 어플리케이션에서 이 방식을 사용하면 된다<br>
OAuth 2.0에서 가장 많이 사용되는 방식이다<br>
권한코드 없이 바로 발급되서 보안에 취약<br>
주로 Read only인 서비스에 사용<br>
로그인시에 페이지 URL에 response_type=token 라고 넘긴다  <br>
OAuth 2.0 묵시적 권한부여는 백엔드 채널이 존재하지 않으며, 웹사이트가 브라우저만 사용하는 정적인 사이트일 때 사용된다. 이 경우에는, application code를 access token으로 변경할 때, 백엔드 채널에서 일어나는 마지막 단계를 생략한다. 묵시적 권한부여에서는 권한부여 서버가 access token을 바로 준다.</p>

<h3 id="password-credentials-grant">
<a class="anchor" href="#password-credentials-grant" aria-hidden="true"><span class="octicon octicon-link"></span></a>Password Credentials Grant</h3>
<p>Client에 아이디/패스워드를 저장해 놓고 아이디/패스워드로 직접 access token을 받아오는 방식이다<br>
Client 를 믿을 수 없을 때에는 사용하기에 위험하기 때문에 API 서비스의 공식 어플리케이션이나 믿을 수 있는 Client에 한해서만 사용하는 것을 추천한다<br>
로그인시에 API에 POST로 grant_type=password 라고 넘긴다</p>

<h3 id="client-credentials-grant">
<a class="anchor" href="#client-credentials-grant" aria-hidden="true"><span class="octicon octicon-link"></span></a>Client Credentials Grant</h3>
<p>어플리케이션이 Confidential Client일 때 id와 secret을 가지고 인증하는 방식이다<br>
로그인시에 API에 POST로 grant_type=client_credentials 라고 넘긴다</p>

<h2 id="53-token">
<a class="anchor" href="#53-token" aria-hidden="true"><span class="octicon octicon-link"></span></a>5.3. Token</h2>
<h3 id="access-token">
<a class="anchor" href="#access-token" aria-hidden="true"><span class="octicon octicon-link"></span></a>Access Token</h3>
<p>앞서 말한 4가지 권한 요청 방식 모두, 요청 절차를 정상적으로 마치면 클라이언트에게 Access Token이 발급됩니다. 이 토큰은 보호된 리소스에 접근할 때 권한 확인용으로 사용됩니다. 문자열 형태이며 클라이언트에 발급된 권한을 대변하게 됩니다. 계정 아이디와 비밀번호 등 계정 인증에 필요한 형태들을 이 토큰 하나로 표현함으로써, 리소스 서버는 여러 가지 인증 방식에 각각 대응 하지 않아도 권한을 확인 할 수 있게 됩니다.</p>

<h3 id="refresh-token">
<a class="anchor" href="#refresh-token" aria-hidden="true"><span class="octicon octicon-link"></span></a>Refresh Token</h3>
<p>한번 발급받은 Access Token 은 사용할 수 있는 시간이 제한되어 있습니다. 사용하고 있던 Access Token 이 유효기간 종료 등으로 만료되면, 새로운 Access Token을 얻어야 하는데 그때 이 Refresh Token 이 활용됩니다. 권한 서버가 Access Token 을 발급해주는 시점에 Refresh Token 도 함께 발급하여 클라이언트에게 알려주기 때문에, 전용 발급 절차 없이 Refresh Token을 미리 가지고 있을 수 있습니다. 토큰의 형태는 Access Token과 동일하게 문자열 형태입니다. 단 권한 서버에서만 활용되며 리소스 서버에는 전송되지 않습니다.</p>

<h3 id="토큰의-갱신-과정">
<a class="anchor" href="#%ED%86%A0%ED%81%B0%EC%9D%98-%EA%B0%B1%EC%8B%A0-%EA%B3%BC%EC%A0%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>토큰의 갱신 과정</h3>
<p>클라이언트가 권한 증서를 가지고 권한서버에 Access Token 을 요청하면, 권한 서버는 Access Token과 Refresh Token 을 함께 클라이언트에 알려줍니다. 그 후 클라이언트는 Access Token을 사용하여 리소스 서버에 각종 필요한 리소스들을 요청하는 과정을 반복합니다. 그러다가 일정한 시간이 흐른 후 Access Token이 만료되면, 리소스 서버는 이후 요청들에 대해 정상 결과 대신 오류를 응답하게 됩니다. 오류 등으로 Access Token이 만료됨을 알아챈 클라이언트는, 전에 받아 두었던 Refresh Token을 권한 서버에 보내어 새로운 Access Token을 요청합니다. 갱신 요청을 받은 권한 서버는 Refresh Token 의 유효성을 검증한 후, 문제가 없다면 새로운 Access Token을 발급해줍니다. 이 과정에서 옵션에 따라 Refresh Token 도 새롭게 발급 될 수 있습니다.</p>

<h2 id="54-openid-connect">
<a class="anchor" href="#54-openid-connect" aria-hidden="true"><span class="octicon octicon-link"></span></a>5.4. OpenID Connect</h2>
<p>OAuth는 유저 인증을 곧바로 제공하지 않지만 권한 부여를 위한 Access Token을 제공한다. OpenID Connect는 권한부여 서버에 의해 작동하는 인증 시스템을 기반으로 클라이언트가 사용자를 판단할 수 있게 해준다. 권한부여 서버에 유저 로그인과 동의를 요청할 때, openid라는 스코프를 정의하면 OpenID Connect 사용이 가능하다. openid는 OpenID가 필요되는 권한부여 서버에 필수적인 스코프이다.</p>

<p>OpenID Connect 인증을 위한 URI 요청은 다음과 같이 만들어진다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://accounts.google.com/o/oauth2/v2/auth?
response_type=code&amp;
client_id=your_client_id&amp;
scope=openid%20contacts&amp;
redirect_uri=https%3A//oauth2.example.com/code
</code></pre></div></div>

<p>이 요청의 결과는 Access Token과 ID 토큰으로 바꿀 수 있는 application code이다. OAuth 플로우가 암묵적 플로우면, 서버는 Access Token과 ID 토큰을 바로 줄 것이다.</p>

<p>ID 토큰은 JWT 또는 JSON 웹 토큰이다. JWT는 header, payload, signature 3가지 부분이 담겨있는 인코드된 토큰이다. ID 토큰을 얻은 이후에, 클라이언트는 payload 부분에 인코드된 사용자 정보를 얻을지 결정할 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "iss": "https://accounts.google.com",
  "sub": "10965150351106250715113082368",
  "email": "johndoe@example.com",
  "iat": 1516239022,
  "exp": 1516242922
}
</code></pre></div></div>

<p>token introspection tool: https://jwt.io/<br>
oauth server(API access management): https://developer.okta.com/<br>
command-line JSON processor: https://stedolan.github.io/jq</p>

<h2 id="-1">
<a class="anchor" href="#-1" aria-hidden="true"><span class="octicon octicon-link"></span></a><br><br>
</h2>

<h1 id="6-ssl-certification">
<a class="anchor" href="#6-ssl-certification" aria-hidden="true"><span class="octicon octicon-link"></span></a>6. SSL Certification</h1>

<h2 id="61-대칭키">
<a class="anchor" href="#61-%EB%8C%80%EC%B9%AD%ED%82%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>6.1. 대칭키</h2>

<h2 id="-2">
<a class="anchor" href="#-2" aria-hidden="true"><span class="octicon octicon-link"></span></a><br><br>
</h2>
<h2 id="62-공개키">
<a class="anchor" href="#62-%EA%B3%B5%EA%B0%9C%ED%82%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>6.2. 공개키</h2>

<h2 id="-3">
<a class="anchor" href="#-3" aria-hidden="true"><span class="octicon octicon-link"></span></a><br><br>
</h2>
<h2 id="63-ssl-인증">
<a class="anchor" href="#63-ssl-%EC%9D%B8%EC%A6%9D" aria-hidden="true"><span class="octicon octicon-link"></span></a>6.3. SSL 인증</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ netstat -lntp # listen하고 있는 포트 확인
</code></pre></div></div>

<h4 id="ssh에-key-pair-추가">
<a class="anchor" href="#ssh%EC%97%90-key-pair-%EC%B6%94%EA%B0%80" aria-hidden="true"><span class="octicon octicon-link"></span></a>ssh에 key pair 추가</h4>
<p>서버에 있는 .ssh 디렉토리 내 파일(authorized_keys)에 public key 추가 하고<br>
cat authorized_keys</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh-rsa 어쩌구저쩌구암호화된기존public키 test-EC2-key
ssh-rsa 어쩌구저쩌구암호화된추가된public키 test-EC2-key
</code></pre></div></div>

<p>클라이언트에서 private key 생성</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ vim second-key.pem
# 추가된public키와pair된어쩌구저쩌구암호화된private키 넣기
$ ssh -i second-key.pem ec2-user@myip -p22 # second key로 접속 확인
</code></pre></div></div>
<p>ssh-add로 해당 세션에 저장 해보기</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh-add test-EC2-key.pem
ssh ec2-user@myip -p22 # 파일 명시 안해도 접속 가능
</code></pre></div></div>

<h2 id="-4">
<a class="anchor" href="#-4" aria-hidden="true"><span class="octicon octicon-link"></span></a><br><br>
</h2>
<h2 id="64-ssl-통신">
<a class="anchor" href="#64-ssl-%ED%86%B5%EC%8B%A0" aria-hidden="true"><span class="octicon octicon-link"></span></a>6.4. SSL 통신</h2>

<h2 id="-5">
<a class="anchor" href="#-5" aria-hidden="true"><span class="octicon octicon-link"></span></a><br><br>
</h2>


  </div><a class="u-url" href="/techblog/restapi/2015/04/16/restapi.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/techblog/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="https://nueees.github.io/techblog/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/techblog/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>A challenge-loving data engineer.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
