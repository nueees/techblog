---
toc: true
layout: post
description: section4
categories: [restapi]
title: REST API & OAuth
---

📎 Coding Everybody

---

# 4. [REST API](https://velog.io/@taeha7b/api-restapi-restfulapi)
REST API(REpresentational State Transfer)는 웹상에서 사용되는 여러 리소스를 HTTP URI로 표현하고, 해당 리소스에 대한 행위를 HTTP Method로 정의하는 방식  
리소스(HTTP URI로 정의됨)를 어떻게 하겠다(HTTP Method + Payload)를 구조적으로 깔끔하게 표현하는 방법  

### REST API의 설계 가이드
리소스에 대한 행위는 HTTP Method(POST, GET, PUT, DELETE)로 표현해야 합니다.  
/(슬래시)는 계층 관계를 나타낼때 사용합니다.  
URI 마지막 문자에 /(슬래시)를 사용하지 않습니다.  
URI에 \_(underscore)는 사용하지 않도록 합니다. 또한 영어 대문자보다는 소문자를 씁니다. 그리고 가독성을 위해서 긴 단어는 잘 사용하지 않습니다.  
URI에 동사는 GET, POST와 같은 HTTP Method를 표현하기 때문이다.  
동사가 아니라 명사를 사용한다.  
URI에 파일의 확장자(예를들어 .json , .JPGE)를 포함 시키지 않습니다.  

# 4.1. [REST API 제약사항](https://sabarada.tistory.com/26) 

## Client-Server
사용자들에게 제공하는 interface인 User Interface와 데이터 스토리지, 알고리즘 등 서버 내부의 작업들을 분리함으로 써 User Interface는 여러 플랫폼에서의 이식성을 향상될 수 있으며, 서버는 그 구성요소를 단순화하여 확장성을 단순화할 수 있습니다.  
클라이언트와 서버가 서로 의존하지 않고 별도로 진화할 수 있습니다. 클라이언트는 서버의 리소스 URI만 알고 있으면 되기 때문입니다.  

## Stateless
클라이언트에서 서버로의 각 요청에는 그 요청을 이해하는 데 필요한 모든 정보가 포함되어야 합니다. 서버에 저장된 환경 정보를 이용해서 이득(서버에서의 클라이언트 정보 유지 등)을 취하면 안 됩니다. 따라서 세션의 정보는 전적으로 클라이언트가 가지고 있어야 합니다.  
로그인했다는 세션 유지가 필요하다면 그 정보 또한 Client가 해당 정보를 가지고 서버에 전달해야 한다. e.g. JWT 등을 사용  

## Cacheable
요청에 대한 응답 내의 데이터에 해당 요청은 캐시가 가능한지 불가능 한지 명시해야 합니다. 응답을 캐시 할 수 있다면 클라이언트에서 동일한 요청이 왔을 때 응답 데이터를 재사용할 수 있어야 합니다.  
cache-control 헤더를 통하여 캐시 여부 명시  


## Uniform Interface
전체적인 시스템 아키텍처를 간단하고 잘 파악할 수 있도록 하기 위한 약속된 Interface, 해당 규약을 REST를 사용자들이 지킴으로써 추후에 사용하는 Client를 개발하는 사용자와 Server를 개발하는 사용자 간의 결합도가 낮아질 수 있다(Decoupling). 개발 [REST는 규약으로 4가지](https://sabarada.tistory.com/9) 를 제시합니다.  

### identification of resources: Resource가 URI로 식별되면 된다  

### manipulation of resources through representations: representations 전송을 통해서 resources를 조작해야 한다  
Representations: HTTP 메소드의 PUT, GET, DELTE 등을 말한다.  

### self-descriptive messages: 메시지 만으로 어떤 메시지 인지 알 수 있어야 한다  
```
Client]
GET / HTTP/1.1
Host: www.example.org

Server]
HTTP/1.1 200 OK
Content-Type: application/json-patch+json
\[{ “op” : “remove”, “path” : “a/b/c"}\]
```


### Hypermedia As The Engine Of Application State: 애플리케이션의 상태는 Hyperlink를 이용해 전이되어야한다. (페이지 변경 등)  
어디서 어디로 전이가 가능한지 미리 결정되지 않는다. 어떤 상태로 전이가 완료되고 나서야 그 다음 전이 될 수 있는 상태가 결정된다. 링크가 동적으로 변경될 수 있음  

```
HTTP/1.1 200 OK
Content-Type: application/json
Link: </articles/1>; rel=“previous”,
      </articles/3>; rel=“next”;
{
    “Title” : “The second article”,
    “content” : “Hello! Brother"
}
```

## Layered System
계층화된 시스템 아키텍처를 사용하여 각 구성들 간의 계층을 마음대로 상호작용 할 수 없도록 제한 함으로 써 Interface를 일원화할 수 있습니다.  

## Code on demand (optional)
서버가 네트워크를 통해 클라이언트에 전달한 javascript 등과 같은 프로그램들은 그 자체로 실행이 될 수 있어야 한다. 이것은 사전 구현에 필요한 기능의 수를 줄임으로써 클라이언트를 단순화합니다.  
이 말은 우리가 평소에는 정적인 데이터를 xml 또는 json에 담아서 client로 보내고 client가 이것을 가공합니다. 하지만 code on demand라는 것은 client에 보내는 데이터를 바로 실행 가능한 코드를 보내서 이것을 Client에서 실행하는 것을 말합니다.  


<br><br>
---

# 5. OAuth

## 5.1.


<br><br>
---

# 6. SSL Certification

## 6.1. 대칭키



<br><br>
---
## 6.2. 공개키



<br><br>
---
## 6.3. SSL 인증

```
$ netstat -lntp # listen하고 있는 포트 확인
```

#### ssh에 key pair 추가  
서버에 있는 .ssh 디렉토리 내 파일(authorized_keys)에 public key 추가 하고  
cat authorized_keys  
```
ssh-rsa 어쩌구저쩌구암호화된기존public키 test-EC2-key
ssh-rsa 어쩌구저쩌구암호화된추가된public키 test-EC2-key
```

클라이언트에서 private key 생성  
```
$ vim second-key.pem
# 추가된public키와pair된어쩌구저쩌구암호화된private키 넣기
$ ssh -i second-key.pem ec2-user@myip -p22 # second key로 접속 확인
```
ssh-add로 해당 세션에 저장 해보기  
```
ssh-add test-EC2-key.pem
ssh ec2-user@myip -p22 # 파일 명시 안해도 접속 가능
```


<br><br>
---
## 6.4. SSL 통신





<br><br>
---



