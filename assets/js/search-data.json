{
  
    
        "post0": {
            "title": "Cloud Service",
            "content": "출처_Building Cloud private native 전문가 양성과정 교재 . 8.클라우드 서비스 소개 . 8.1. 클라우드 서비스 개요 . 네트워크를 이용해서 사용자들이 원하는 방식으로 서비스를 제공 | 확장성 | 사용 모델 | 분산 | 개인 시스템의 성능에 구애받지 않음 | . 장점 . 초기 구성 비용 절감 | 초기 구성 시간 절약 | 확장성이 | . 단점 . 오랜 기간 사용할 경우 비용 부담 증가 | . 8.2. 클라우드 서비스 분류 . SaaS (Software as a Service): 서비스로서 소프트웨어 애플리케이션 서비스를 제공 . 보통 IaaS, PaaS위에 올라가고, 중앙에서 호스팅되고 있는 소프트웨어를 웹 브라우저 같은 애플리케이션을 통해 사용 ex) Google Docs . PaaS (Platform as a Service): 서비스로서 플랫폼 소프트웨어를 제공 . SaaS의 개념을 개발 플랫폼으로 확장한 방식 플랫폼(OS)를 웹에서 쉽게 빌려 사용 확장성과 경제적 이유로 On-Premise환경을 Cloud로 확장 ex) Google APP Engine, OpenShift . IaaS (Infrastructure as a service):서비스로서 인프라 자원 제공 . Server, Storage, Network를 가상으로 만들어 사용자가 필요한 자원 사용 관리와 책임이 클라우드 소비자에게 존재 . ex) 대부분 퍼블릭 클라우드 서비스 (AWS EC2, S3) . 8.3. 클라우드 서비스 종류 . Private Cloud . 자체적으로 데이터센터 안에 클라우드 환경 구축 . 자산 스스로 보유, 구축 | 기존 IT 인프라 자원 활용 가능 | 소규모로 구축할 때 비용이 높음 | 보안 서비스를 자체적으로 구축해야 함 | . Public Cloud . 비용을 지불하고 서비스 제공 업체가 구축한 Server, Storage, Network 등 IT Infra 사용 . 공용 클라우드는 가입 형태의 서비스 | 대규모 서비스로 구축 시 비용 절감 | 서비스 제공자가 구축한 보안 서비스 안에서 운용 | . Hybrid Cloud . 공용 + 사설 클라우드의 장점만 선택해서 사용 . 필요에 의해 데이터나 컴퓨팅 자원의 위치 조절 | 데이터의 중요도와 비즈니스 핵심 업무 여부에 따라 선택 가능 | .",
            "url": "https://nueees.github.io/techblog/kubernetes/2021/10/04/Cloud-Service.html",
            "relUrl": "/kubernetes/2021/10/04/Cloud-Service.html",
            "date": " • Oct 4, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Container Cluster Kubernetes",
            "content": "출처_Building Cloud private native 전문가 양성과정 교재 . 5.Container Cluster . 5.1.Kubernates 소개 . docker - 단일 시스템에서만 다수의 컨테이너 관리 -&gt; 다수의 시스템과 애프리케이션 설정을 쉽게 설정하고 유지보수할 수 있는 방식인 오케스트레이션(Ochestration)이 필요 kubernates - 구글에서 개발된 컨테이너 오케스트레이션 도구 . 다중 컨테이너 관리를 위한 docker-compose를 설치해야 함. . 쿠버네티스는 클러스터 구성해서 오케스트레이션을 통해 컨테이너를 자동으로 관리, 2개 이상 시스템에서 관리 가능 관리 대상을 object라고 함 - pods(컨테이너 단위)와 controller(pods를 한번에 관리)로 구성(application workload) . 기능 . 컨테이너 플랫폼, 마이크로서비스 플랫폼, 이식성있는 클라우드 플랫폼 제공 . CI/CD 파이프라인, 애플리케이션 레벨의 서비스, 로깅, 모니터링, 경고 솔루션 등을 제공하지 않음 . . 사전 설치 . choco 패키지 관리도구 설치 | $ Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager ]::SecurityProtocol = [System.Net.ServicePointManager ]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(&#39;[https://community.chocolatey.org/install.ps1&#39;](https://community.chocolatey.org/install.ps1&#39;))) | vagrant 설치혹은 vagrant.exe 파일 다운로드 후 설치 가능 | $ choco install vagrant | 하이퍼바이저 설치 virtualbox 설치 (확장팩) | vagrant 명령어로 구성요소 설치 vagrant plugin install vagrant-hostmanager vagrant plugin install vagrant-disksize 확인: vagrant plugin list윈도우의 경우 직접 작성하면 확장자이름이 자동설정될 수 있으니 주의 | $ vagrant box add ubuntu /bionic64 $ vagrant up =&gt; Vagrantfile 이 있는 곳에서 실행 | 가상머신에 쿠버네티스 배포 ssh 설정 | $ ssh-keygen $ ssh-copy-id node1 (노드 모두 입력) localhost 도 설정 | . kubenates 설치 . 1. 패키지 및 git 설치 $ sudo apt update $ sudo apt upgrade -y $ sudo apt install -y python3 python3-pip git $ git clone --single-branch --branch release-2.14 https://github.com/kubernetes-sigs/kubespray.git $ cd kubespray/ $ sudo pip3 install -r requirements.txt` 2. 인벤토리 수정 $ cp -rfp inventory/sample/ inventory/mycluster $ vim inventory/mycluster/inventory.ini [all] node1 ansible_host=192.168.56.21 ip=192.168.56.21 node2 ansible_host=192.168.56.22 ip=192.168.56.22 node3 ansible_host=192.168.56.23 ip=192.168.56.23 controll-plane ansible_host=192.168.56.11 ip=192.168.56.11 [all:vars] ansible_python_interpreter=/usr/bin/python3 [kube-master] controll-plane [etcd] controll-plane [kube-node] node2 node3 node1 [calico-rr] [k8s-cluster:children] kube-master kube-node calico-rr` $ sudo vim /etc/hosts 192.168.56.11 controll-plane.example.com controll-plane 192.168.56.21 node1.example.com node1 192.168.56.22 node2.example.com node2 192.168.56.23 node3.example.com node3 $ vim inventory/mycluster/group_vars/k8s-cluster/addons.yml metrics_server_enabled: true ingress_nginx_enabled: true metallb_enabled: true metallb_ip_range: - &quot;192.168.56.50-192.168.56.99&quot; metallb_protocol: &quot;layer2&quot; $ vim inventory/mycluster/group_vars/k8s-cluster/k8s-cluster.yml kube_proxy_strict_arp: true 3. 플레이북 실행 $ ansible-playbook -i inventory/mycluster/inventory.ini cluster.yml -b` 4. kubectl 설치 $ curl -LO &quot;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl&quot; $ curl -LO &quot;https://dl.k8s.io/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256&quot; $ echo &quot;$(&lt;kubectl.sha256) kubectl&quot; | sha256sum --check $ sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl $ kubectl version --client` . . 5.1.Architecture . . kube-api-server를 통해서 대부분의 작업을 함 kube-controller-manager : on-premise 환경에서 각 리소스 관리 cloud-controller-manager : cloud 환경에서 밴더사 자체적으로 관리 . 마스터(master) . cluster를 구성하기 위한 핵심 요소들의 모음 cluster 조정을 위한 control plane 제공 노드에 작업 분배하는 scheduling 작업 cluster evnet 감지하고 대응 운영환경에서는 multi master 환경을 구성 (FT) . 1) API 서버(kube-apiserver) API는 . 2) etcd cluster의 meta 정보 정장 key-value 형태로 저장 cluster configuration 정보 보관하고 있으므로 백업 필수 . 3) scheduler cluster 내 생성되는 pod를 감지하고 실행할 노드를 선택 resourse 상태, HW/SW/Policy 제약, Affinity 등 다양한 기준에 따라 배치 결정 . 4) cube-controller-manager . node controller: 노드 관리, 노드 다운시 대응 | replication controller: 복제 컨트롤러를 사용하는 모든 object관리, 적정 pod 수 유지 | endpoint controller: service와 pod 연결 (물리적 시스템과 컨테이너 내부 어플리케이션 연결) | service account &amp; token controller: 쿠버네티스 namespace, account, token 등 인증 관련된 것 담당 | . 5) cloud-controller-manager . AWS, GCP 등 각 밴더 별 클라우드 서비스 관리 . node controller: 노드 관리, 노드 다운시 대응 | route controller: 클라우드 환경의 네트워크 경로 | service controller: 클라우드 로드밸런서 관리 | volume controller: 클라우드 볼륨 관리 | . 노드(node) . container를 실행하고 싶은 만큼 구성 monion, worker 노드 라고도 함 . 1) kubelet 각 노드에서 실행되는 agent로 마스터로부터 제공받은 구성 정보, 노드가 수행해야할 작업 동작 . 2) kube-proxy 네트워크 프록시로, 서비스를 구현하기 위한 기능 컨테이너에 연결될 네트워크 구성 관리 . 3) container runtime 실제 컨테이너 동작을 책임지는 구성요소 . Docker | containerd | CRI-O | rktlet | Kubernetes CRI(Container Runtime Interface) | . 추가 요소(add-on) . 구성요소 설명 . 클러스터 DNS | 쿠버네티스 클러스터 내의 여러 오브젝트에 대하여 주소기반으로 오브젝트를 접근할 수 있는 DNS 제공 | . DashBoard | 모니터링 용 웹기반 인터페이스 | . 컨테이너 resource 모니터링 | 컨테이너 리소스 사용량의 시계열 매트릭스 기록 | . 클러스터 logging | 컨테이너 로그를 중앙로그저장소에 저장하고 관리, 로그를 검색/열람하는 인터페이스 제공 | . 쿠버네티스 API . 1) API 버전 규칙 alpha 버전 API : 개발 초기 버전 beta 버전 API : 일정 수준 이상 테스트가 된 버전 stable 버전 : vX 형태의 안정화된 버전 . 2) API 그룹 core group: apiVersion:[version] core 이외 group: apiVersion: [group]/[version] . . 5.3.Menifest . 필드 설명 . apiVersion | object를 생성하기 위한 API 버전을 지정 | . kind | object 종류 | . metadata | name, label, namespace 등 기본정보 | . spec | object 세부 상태 | . Managing Object . 1) Imperative commands(명령형 커맨드) 재사용성이 떨어져 개발 환경에서 테스트 시, 일회성 작업일 경우 사용 . $ kubectl run nginx --image nginx . 2) Imperative object configuration(명령형 오브젝트 구성) yaml, json 포맷으로 파일을 작성하여 kubectl은 작성된 파일을 참고하여 실행 . $ kubectl create -f nginx.yaml . 3) Declarative object configuration(선언형 오브젝트 구성) 특정 디렉토리에 오브젝트 파일을 배치하고 작성된 파일을 참고하여 오브젝트 관리 . $ kubectl diff -f configs/ $ kubectl apply -f configs/ . Running App with Imperative commands 예시 . $ kubectl run mytest-app --image=&lt;ACCOUNT&gt;/myweb --port=8080 --generator=run/v1 # 레플리케이션 컨트롤러(pod) 생성 $ kubectl get pods $ kubectl get replicationcontrollers $ kubectl expose replicationcontroller mytest-app --type=LoadBalancer --name myweb-svc # 서비스 생성 $ kubectl get services $ curl http://192.168.56.11:31289 $ kubectl scale replicationcontroller mytest-app --replicas=3 $ kubectl get pods $ kubectl get replicationcontrollers $ curl http://192.168.56.11:31289 $ kubectl get all $ kubectl delete replicationcontrollers mytest-app $ kubectl delete service myweb-svc . . 6.Application Workload . 6.1.Pods . 도커에서 작업을 수행하기 위해 구동해야 하는 가장 작은 단위는 컨테이너 1 컨테이너 = 1 애플리케이션 Pod : 쿠버네티스에서 작업을 수행하기 위해 구동해야 하는 가장 작은 단위 쿠버네티스 클러스터 내에서 애플리케이션 배포하며 동작하는 단위 하나의 Pod는 하나의 node에서만 동작 쿠버네티스 클러스터는 여러 개의 노드로 구성되며 각 노드는 컨테이너를 구동할 수 있도록 준비하고 있으나, 하나의 파드에 두개 이상의 컨테이너가 포함된 경우 각 컨테이너를 여러 노드에 분산시켜서 실행할 수는 없음. 1 pod 내 있는 컨테이너는 저장소, 네트워크 IP 등 공유 . Pod 정의: YAML 파일 생성 | cat testapp-pod.yml . . 기본적인 apiVersion, kind, metadata, spec 포함 - 하이픈 기호는 리스트(List)를 의미 . Pod 생성 및 확인 | $ kubectl create -f testapp-pod.yml $ kubectl get pods $ kubectl get pods testapp-pod -o yaml(-o json) $ kubectl discribe pods testapp-pod $ kubectl logs testapp-pod # 로그 확인 $ kubectl port-forward testapp-pod 8080:8080 # 포트포워딩 $ curl http://localhost:8080 | Label(레이블) 및 Selector(셀렉터) Label: 쿠버네티스 클러스터의 모든 오브젝트에 키/값 쌍으로 이루어진 값을 설정하여 리소스 식별, 속성 지정 역할 네임스페이스 내 중복 불가 Label Selector: Label을 식별하고 검색함 | cat testapp-pod-label.yml . . Anotation(어노테이션) 오브젝트의 추가 정보를 기록하는 경우 사용하는 주석 | $ kubectl annotate pods testapp-pod devops-team/developer=&quot;nueees&quot; | Name Space(네임스페이스) Name Space: 쿠버네티스 클러스터 내 오브젝트와 리소스를 용도와 목적에 따라 논리적으로 완전히 분리된 환경default: 기본 네임스페이스 kube-node-lease: 쿠버네티스 노드(마스터/노드)의 가용성 체크를 위한 네임스페이스 kube-public: 모든 사용자 접근가능 kube-system: 클러스터의 리소스가 배치되는 네임스페이스 | $ kubectl get namespaces | Liveness Prove(라이브니스 프로브) 파드 상태가 정상적인지 주기적으로 모니터링 서비스 | HTTP GET Prove: 특정 경로에 HTTP GET 요청, HTTP 응답코드가 2XX/3XX인지 확인 | TCP Socket Prove: 특정 TCP port 연결 시도 | Exec Prove: 컨테이너 내부의 바이너리(명령)를 실행하고 종료 코드 확인 cat testapp-pod-liveness.yml | . $ kubectl create -f testapp-pod-liveness.yml . . 6.2.Controller . 사용자가 의도한 상태로 유지 해 주는 기능 . ReplicaSet (레플리카셋) . 사용자가 요구하는 복제본 개수만큼 Pod를 복제하고 관리하는 기능 . Pod의 다중 레이블 조건 지원 | Pod에 설정된 레이블의 키 조재 여부 조건 선택 가능 | . cat testapp-rs.yml . . $ kubectl create -f testapp-rs.yml $ kubectl get replicasets.apps . cat testapp-rs-exp.yml . . $ kubectl create -f testapp-rs-exp.yml $ kubectl get replicasets.apps -o wide . DaemonSet (데몬셋) . 쿠버네티스 클러스터는 부하 분산, 이중화를 통한 장애 대응 목적 등을 위하여 최소 하나 이상의 노드로 구성되므로 다수의 노드를 사용할 경우 필요에 따라 각 노드별*로 특정 목적을 수행하는 *파드를 한 개씩 배치하여야 하는 경우 발생 . 레플리카셋과 비슷하지만 복제본을 지정하지 않음 . cat testapp-ds.yml . . nodeSelector에 Pod가 배포될 노드 선택 . $ kubectl create -f testapp-ds.yml $ kubectl get replicasets.apps -o wide $ kubectl label nodes kube-node1 node=development # node에 label지정 $ kubectl label nodes kube-node1 --show-label . . 7.Network - Service . 7.1. Service 생성 . Service: 쿠버네티스 시스템에서 같은 애플리케이션을 실행하도록 구성된 컨트롤러에 의해 생성된 Pod 그룹에 단일 네트워크 진입점 제공 . 서비스에 부여된 IP는 해당 서비스가 종료될 때까지 유지하고 클라이언트는 이 서비스에 부여된 고정 IP 및 PORT를 통해 Pod에 접근 가능 . cat testapp-svc.yml . . $ kubectl create -f testapp-svc.yml $ kubectl get services # 진입점인 서비스 $ kubectl get endpoints testapp-svc # 엔드포인트 -&gt; 레플리카셋 컨트롤러의 파드 . 엔드포인트: 최종 목적지인 파드의 주소 및 포트 정보 . $ kubectl run nettool -it --image= &lt;ACCOUNT &gt;/network-multitool # 서비스 접근 테스트 . Session Affinity: 클라이언트가 특정 파드(웹서비스) 요청 시 이전에 처리된 파드로 동일하게 전달하여 처리 . cat testapp-svc-ses-aff.yml . . $ kubectl create -f testapp-svc-ses-aff.yml . Configuring Service Multi-Port . Pod는 하나 이상의 컨테이너로 구성되어 있어서, 각 컨테이너는 서로 다른 포트 사용 가능 . cat testapp-svc-multiport.yml . . $ kubectl create -f testapp-svc-multiport.yml . Configuring Service by named-port . 레플리카셋 컨트롤러의 Pod 템플릿에서 생성될 컨테이너의 포트에 이름을 부여하여 포트 이름 구성 가능 . cat testapp-rs-named-port.yml . . cat testapp-svc-named-port.yml . . $ kubectl create -f testapp-rs-named-port.yml -f testapp-svc-named-port.yml . 7.2. Service 탐색 . kubectl get 명령어로 IP 주소를 수동적으로 확인할 수 있지만 Object끼리 통신을 위한 방식 필요 . 환경변수 방식 | 쿠버네티스 클러스터 내 DNS 사용 방식 | DNS를 이용한 Service 탐색 . kube-systme 네임스페이스에서 쿠버네티스에 등록된 구성요소 확인 가능 그중 k8s-app=kube-dns 레이블 옵션을 통해 DNS 관련 파드 확인 . 1) DNS 관련 리소스 확인 . $ kubectl get all -n kube-system -l k8s-app=kube-dns . 2) 파드 내부 DNS 설정 확인 이름 기반의 주소로 네트워크에 접근하기 위해서 DNS 설정 필요 . $ kubectl exec testapp-rs-m65m4 -- cat /etc/resolv.conf # 위의 coredns 서비스 IP와 다름 . 각 파드의 DNS로 등록되어 있는 위 IP(169.254.0.0/16 형식)는 IPv4 주소형식에서 ‘Link Local Address’이며, 유효한 IP 주소가 아님 3) NoceLocal DNSCache 해당 주소(169.254.25.10)는 coreDNS로 직접적으로 요청이 전달되지 않게 하는 중간 단계 캐시 DNS DaemonSet 형태로 쿠버네티스의 각 노드마다 DNS 캐시 기능을 하는 Pod 배치하여 필요한 경우에만 CoreDNS 호출하는 구조 . Pod &lt;-&gt; NodeLocal DNSCache &lt;-&gt; iptables &lt;-&gt; coreDNS . $ kubectl get daemonsets.apps -l k8s-app=kube-dns -n kube-system # 각 노드별 데몬셋 컨트롤러 확인 $ kubectl get pods -l k8s-app=kube-dns -n kube-system | grep -A 2 Args # node local dns 확인 $ kubectl run nettool -it --image= &lt;ACCOUNT &gt;/network-multitool --generator=run-pod/v1 --rm=true bash # 서비스 접근 테스트 . 주소구성: &lt;리소스(서비스) 이름&gt;... . 7.3. Service 종류 . 위의 내용은 내부 접근이고, 외부 접근 제공하는 서비스 구성 필요 . ClusterIP: 클러스터 내부용 진입점 제공 . NodePort: 쿠버네티스 각 노드(호스트)의 포트를 외부 접근용으로 할당 . LoadBalancer: NodePort의 확장판으로, 외부 로드밸러서로 접근하면 서비스를 통해 파드로 Redirection . ExternalName: 외부에서 접근하기 위한 서비스 유형이 아닌, CNAME 매핑을 통해 특정 FQDN과 통신을 위한 기능 . 외부 접근용 레플리카셋 생성 및 확인 | $ kubectl create -f testapp-rs.yml $ kubectl get replicasets.apps $ kubectl get pods | NodePort 서비스 생성 cat testapp-svc-ext-nodeport.yml | $ kubectl create -f testapp-svc-ext-nodeport.yml # 해당 노드에서 사용할 포트 31111로 지정 $ kubectl get endpoints testapp-svc-ext-np # 서비스의 엔드포인트 확인 (Pod의 8080 포트로 Redirection 됨) $ kubectl get nodes -o wide # 각 노드의 IP 확인 | LoadBalancer 서비스 생성 cat testapp-svc-ext-loadbalancer.yml | $ kubectl create -f testapp-svc-ext-loadbalancer.yml # 해당 노드에서 사용할 포트는 정의하지 않음 $ kubectl get services # LoadBalancer 서비스 확인 | ExternalName 서비스 생성 cat testapp-svc-ext-externalname.yml | $ kubectl run nettool -it --image= &lt;ACCOUNT &gt;/network-multitool --generator=run-pod/v1 --rm=true bash # 서비스 접근 테스트 $ nllookup testapp-svc-extname-gl | $ kubectl create -f testapp-svc-ext-externalname.yml # FQDN은 google이며 이에 대한 CNAME은 testapp-svc-extname-gl $ kubectl get services # ExternalName 서비스 확인 | .",
            "url": "https://nueees.github.io/techblog/kubernetes/2021/10/03/Container-Cluster-Kubernetes.html",
            "relUrl": "/kubernetes/2021/10/03/Container-Cluster-Kubernetes.html",
            "date": " • Oct 3, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Docker Image Build",
            "content": "출처_Building Cloud private native 전문가 양성과정 교재 . 3.Building Docker Image . Dockerfile . # docker run -it --name c1 centos # yum -y install httpd &gt; /dev/null ## systemctl start httpd ## systemctl enable httpd # httpd 이미지는 CentoOS와 호환되지 않아 설치 시 오류 발생 # docker inspect centos # container boot시 명령어가 지정되어 있음 ( &quot;Cmd&quot;: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;#(nop)&quot;, &quot;CMD [ &quot;/bin/bash &quot;]&quot;...) # dodker inspect httpd # ( &quot;Cmd&quot;: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;#(nop)&quot;, &quot;CMD [ &quot;httpd-foreground &quot;]&quot;...) . 이 경우 직접 컨테이너를 구동하고 수정하는 방식으로는 특정 어플리케이션 지정할 수 없음 Dockerfile을 사용해야 함 . Dockerfile 생성 . # mkdir dftest1 # cd dftest1 # vi Dockerfile FROM httpd:latest MAINTAINER nueees RUN yum -y install httpd COPY index.html /var/www/html CMD /usr/sbin/httpd -D FORGROUND # docker build -t test:1.0 . # 현재 디렉토리(.)로 빌드 # docker images # test:1.0으로 추가된 것 확인 . base image (베이스 이미지) | command (실행 명령) | env (환경 변수) | run (실행 데몬) | 명령어 설명 . FROM | 베이스 이미지 지정 | . MAINTAINER | 작성자 지정 | . RUN | 명령어 실행 | . CMD | 데몬 실행 | . LABEL | 라벨 지정 | . EXPOSE | 포트 내보내기 | . ENV | 환경변수 설정 | . ADD | 파일 추가 | . COPY | 파일 복사 | . VOLUME | 볼륨 마운트 | . ENTRYPOINT | 데몬실행 | . USER | 사용자 설정 | . WORKDIR | 작업 디렉토리 설정 | . ONBUILD | build 후 실행 명령 | . . Docker image build . # docker build -help # cat /root/file/Dockerfile # docker build -t base:1.0 /root/file/ # docker images . docker layer 구조 . # docker build -t base:1.0 /root/file # 실행시 레이어 구조가 하나씩 나옴 . setp 1/5 : FROM centos | step 2/5 : MAINTAINER nueees | step 3/5 RUN yum -y install httpd | step 4/5 COPY index.html /var/www/html | step 5/5 CMD /usr/sbin/httpd -D FORGROUND | . 4.Docker Image Registry . Docker image registry? . Registry - Docker Image Registry . 도커 허브에 공개되어 있는 registry 공식 이미지 . # docker search registry # docker pull registry:2.0 # docker images # docker run -d -p 5000:5000 --name regTest registry:2.0 # docker tag httpd localhost:5000/regTest # docker push localhost:5000/regTest # upload # docker rmi localhost:5000/regTest # docker pull localhost:5000/regTest # download # docker images . Harbor - Docker Image Registry . one of private registries web 기반, 다양한 기능 제공 . docker-compose 설치 . # curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose # chmod +x /usr/local/bin/docker-compose # docker-compose --version . Harbor 설치 파일 download . # wget &quot;https://github.com/goharbor/harbor/releases/download/v2.3.3/harbor-offline-installer-v2.3.3.tgz&quot; # tar xzvf harbor-offline-installer-version.tgz . HTTPS 구성 후 . Configuration File(YML File) 수정 . # vi harbor.yml 5 hostname: docker.nueees.co.kr 13 https: 15 port: 443 17 cerificate: 18 private_key: . Harbor 설치 . # systemctl restart docker # ./install.sh . Harbor 사용 . # docker login -u admin -p Harbor12345 192.168.56.101 # docker tag centos:latest 192.168.56.101/library/docker:centos # docker push 192.168.56.101/library/docker:centos # docker rmi 192.168.56.101/library/docker:centos # docker pull 192.168.56.101/library/docker:centos . 웹에서 Harbor IP 접속하여 대시보드 확인 . .",
            "url": "https://nueees.github.io/techblog/kubernetes/2021/10/02/Docker-Image-Build.html",
            "relUrl": "/kubernetes/2021/10/02/Docker-Image-Build.html",
            "date": " • Oct 2, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Docker Container Configuration & management",
            "content": "출처_Building Cloud private native 전문가 양성과정 교재 . 1.Docker Container . Container &amp; Virtualization . 하드웨어 성능이 올라가면서, 유휴자원을 활용하는 가상화(자원을 나눠서 사용) 기술이 대두됨. . 가상화 종류 . Hypervisor Virtualization(Native/Bare Metal): 하드웨어 위에 OS 대신 하이퍼바이저를 설치하고 가상(개별OS)머신 생성 (Hyper-V,XenServer) | Host Virtualization: 하드웨어 위에 OS 설치하고, 하이퍼바이저 설치 후, 가상(개별OS)머신 생성 (VMware, VirtualBox) | Container Virtualization: 하드웨어 위에 OS설치하고, 컨테이너 runtime 관리 S/W 설치 후 가상(App)머신 생성 (Docker) 개별운영체제X, 호스트 OS의 일부를 공유하는 방식 사용, overhead 적음 | 그밖에 Application/Network/Storage Virtualization 있음. | . Docker Architecture . Docker’s strengths . don’t need a guest OS | Transplant : easily ported across different platforms | support On-Premise, Cloud, and DevOps open source | . Docker’s main function . Image 생성/관리 image는 컨테이너 구동을 위한 데이터 생성시 코드로 기술 가능(Infrastructure as Code, IaC) | Image 공유 Registry는 Image의 저장소 (Ubuntu, Debian, CentOS, Fedora의 기본 이미지, 다양한 소프트웨어 탑재 된 이미지 제공) 다운로드, 업로드, 버전 관리 가능 | Container 운영 이미지 상태의 파일 -&gt; 프로세스로 띄움 시작, 중지, 삭제 작업 | . 컨테이너 간 간섭을 방지하기 위해 Isolation 기술 (리눅스 namespace와 cgroup 기능) 사용 . technique for Docker : 리눅스 커널 . 독립된 환경 네임스페이스(namespace) 네임스페이스 별로 독립된 PID, Network, UID, MOUNT, UTS, IPC 사용 | 제어그룹 (cgroup) Process 또는 Thread를 그룹화 하여 관리 - CPU나 Memory를 그룹별로 제한 가능 | 가상 Bridge와 가상 NIC(Network Interface Card) 컨테이너 별 각각의 가상 NIC가 할당(ContainerA - eth0, ContainerB - eth0) 가상 NIC는 docker0(172.17.0.0/16)라는 가상 bridge로 연결되어 컨테이너끼리 또는 호스트(물리NIC)를 통해 외부 네트워크로 연결 (Host - eth0) | 계층 파일 시스템 기본 컨테이너 이미지에 추가 작업 시 COW(Copy on Write)* 방식으로 생성 COW 방식은 부모 프로세스가 자식 프로세스를 생성할 때 전부 복제하지 않고, 쓰기가 발생했을 때 변경된 부분만 복제하는 방법과 유사 도커 이미지관리에 사용되는 FS or Library : Btrfs, AUFS, Device Mapper, OverlayFS | . . 2.Managing Docker Container . Installing Docker Engine . 도커 패키지 리포지토리 연결 및 설치 . # yum install -y yum-utils # 필요 util 설치 # yum-config-manager --add-rep https://download.docker.com/linux/centos/docker-ce.repo # 도커 구성 매니저 설치 # yum repolist # yum -y install docker-ce docker-ce-cli containerd.io # 도커 설치 # yum list docker-ce # systemctl start docker.service # 서비스 시작 # systemctl enable docker.service # systemctl is-active docker.service # docker --help . Docker container image . 도커 이미지 관리 . # docker search --help # docker search centos -s 1000 # repository에서 centos 검색 # docker pull --help # docker pull centos # repository에서 centos 가져오기 # docker images # docker tag --help # docker tag centos:latest centos:ver7 # centos 태그 latest-&gt;ver7로 변경 # docker rmi --help # docker rmi centos # centos image 제거 # docker image prune # 이름없는 dangling 이미지 제거 # docker login # docker tag centos:latest nueees/repo-web:centos # docker push --help # docker push nueees/repo-web:centos . . Docker container management . 도커 컨데이너 관리 . # docker create --help # docker create -it --name c1 centos # centos 이미지로 c1라는 컨테이너 생성 # docker ps --help # docker ps -a # docker inspect --help # docker inspect c1 # # docker start --help # docker start c1 # docker stop --help # docker stop c1 # docker run --help # docker run -it --name c2 centos # docker run -d --name web1 httpd # docker rm -f web1 . run (create+start) exit -&gt; 컨테이너 종료 Ctrl+P+Q -&gt; 컨테이너 종료하지 않고 빠져나옴 . # docker attach --help # docker run -itd --name c1 centos # docker attach c1 # background에 실행중인 c1 컨데이너 접근 # docker exec --help # docker run -d --name web1 httpd # docker exec -it web1 bash # web1 컨테이너 접근해서 bash 실행 # docker top --help # docker top web1 # web1 컨테이너에서 실행중인 process 확인 # docker top web1 aux # docker rename --help # docker rename c1 newc1 # docker pause --help # docker pause web1 # docker unpaues web1 # docker cp --help # docker run -itd --name c1 centos # docker cp dockercp.txt c1:/ # host file -&gt; container c1의 /경로로 copy # docker exec -it c1 cat /dockercp.txt # docker diff --help # docker attach c1 ## rm -f anaconda-post.log # 기존 컨테이너 내 log 삭제 후 # docker diff c1 # docker commit --help # docker commit c1 centos:hello # 기존 c1 container로 new image 생성 # docker images # docker save --help # 여러개 이미지를 archive file로 저장 시 # docker save -o imgarc.tar centos:hello httpd:latest # centos:hello, httpd 두개 image를 archive file로 저장 # docker load --help # docker load -i imgarc.tar # archive file에 저장된 이미지 불러오기 # docker images # 불러온 이미지 확인 # docker export --help # 컨테이너 파일시스템을 archive file로 추출 # docker attach c1 ## echo &quot;This is export test&quot; &gt; export.txt # docker export -o testexport.tar c1 # tar tf testexport.tar | grep export.txt # docker import --help # export로 컨테이너로 추출한 archive file로 이미지로 생성 # docker import testexport.tar export:test . 컨테이너 네트워크 구성 . # ip a s # brctl show # docker run -itd --name c1 centos # brctl show # docker attach c1 ## yum -y install net-tools ## ifconfig ## rount -n # docker0는 172.17.0.0/16 네트워크 사용하고 외부 통신 가능 ## ping -c2 google.co.kr # iptables -L -t nat # 게이트웨이 172.17.0.1이며 마스커레이딩 설정 됨 # docker network --help # docker network ls # 도커 네트워크는 bridge, host, none 세가지 # docker inspect bridge # docker network create --help # docker network create d-net # bridge 유형으로 도커 네트워크 생성 # docker inspect d-net # 네트워크 범위(subnet) 자동으로 172.18.0.0/16으로 설정 # docker network create --subnet 192.168.0.0/24 --gateway 192.168.0.254 custom-net # docker run -it --net custom-net --name a1 alpine # 사용자 정의 custom-net 네트워크 사용하여 컨테이너 생성 # docker run -it --net host --name a2 alpine # host 유형으로 생성시 host 네트워크를 공유 ## ifconfig # docker run -it --net none --name a3 none alpine # none 유형은 네트워크 할당 안함 ## ifconfig . 컨테이너 통신 . # docker run -itd --name a1 alpine # docker run -itd --name a2 --link a1 alpine # docker attach a2 ## ping a1 # ping 감 # docker attach a1 ## ping a2 # ping 가지 않음 # docker exec a1 cat /etc/hosts # docker exec a2 cat /etc/hosts # a1이 등록된 걸 확인 # docker run -itd --name a3 --link a1:alpine1 alpine # 별칭으로 링크 등록 # docker exec a1 ping alpine1 # ping 감 # docker exec a3 cat /etc/hosts # a1과 alpine1으로 등록된 걸 확인 # docker run -d --name web1 httpd # curl localhost # container에서는 80포트가 열려있으나 실제 host의 주소로 접근 불가 # docker run -d -p 80:80 --name web2 httpd # host의 port 80으로 요청오면 container 80으로 전달 (호스트:컨테이너) . 호스트의 특정 포트가 컨테이너 포트와 연결되어 있으면 해당 포트는 다른 컨테이너와 연결될 수 없음. . 컨테이너 볼륨 . # mkdir volume # echo hello &gt; volume/hello.txt # docker run -it -v /boot/volume:/mnt --name v1 centos # host 디렉토리를 container와 공유 (호스트:컨테이너) ## ls /mnt ## cat /mnt/hello.txt ## df -h # /mnt 디렉토리가 host의 /dev/sda1에 연결되어 있음 # mkdir vol1 vol2 vol3 # docker run -it -v /boot/vol1:/vol1 -v /boot/vol1:/vol1 -v /boot/vol1:/vol1 --name v2 centos # 동시에 다수 볼륨도 연결가능 # docker run -it -v /boot/vol1:/vol1 --name c2 centos # 하나 볼륨을 동시에 Read-Write시 crash 발생 # docker run -it -v /boot/vol1:/vol1:ro --name c3 centos # 볼륨 공유시엔 하나 외 나머지는 Read-Only로 ## touch /vol1/xxx # docker run -it -v vol-1:/vol1 --name c1 centos # host에서 디렉토리 생성없이 docker volume 생성 후 연결 (도커볼륨:컨테이너) ## touch /vol1/x # docker run -it -v vol-1:/vol1 --name c2 centos ## ls /vol1 # 파일 x 확인 가능 # docker volume ls # docker 볼륨 확인 # docker inspect vol-1 # 실제로는 host 디렉토리 사용 # docker volume create --help # docker volume create vol2 # 수동으로도 생성 가능 # docker run -it --name m1 mysql # docker inspect m1 # 도커 볼륨을 자동으로 생성하는 이미지가 있음 (&quot;Volumes&quot;:{...) # docker volume ls # 생성된 볼륨 확인 . 컨테이너 환경변수 설정 . # docker run -it -e a=100 --name c1 centos ## echo $a # docker run -it --name db1 mysql # error 출력되며 env 설정 필요 # docker ps -a # docker inspect db1 # (&quot;Entrypoint&quot;:[...) # docker run -d -e MYSQL_ROOT_PASSWORD=1234 --name db2 mysql # 환경변수 주고 실행 . 보통 inpsect 내 “Cmd”:[“mysql”]가 실행되나, Entrypoint가 지정되어 있으면 “Entrypoint”:[“docker-entrypoint.sh”]이 우선 실행됨 . 컨데이너 로그 확인 . # docker logs --help # docker logs db1 # 위 환경변수 오류 error log 확인 가능 # docker logs --tail 2 db2 # docker logs --since &quot;2021-10-12T01:00&quot; db2 . 컨테이너 자원 할당 . # docker run -d --name web1 httpd # options 없이 자원 할당 # docker stats web1 # 최대치 할당 # docker run -d --name web2 --memory=&quot;200m&quot; httpd # docker stats --no-stream web1 # 메모리 limit 200MB # # docker update --help # docker update --memory=500m web2 # up가능하나 down은 불가 # docker run -itd -c 10 --name a1 alpine # 가중치 1로 할당 # docker run -itd -c 20 --name a2 alpine # 가중치 2로 할당 # docker attach a1 ## dd if=/dev/zero of=/dev/null &amp; # docker attach a2 ## dd if=/dev/zero of=/dev/null &amp; # docker stats # cpu 사용률 a2가 a1의 두배 확인 # docker run -itd --name a3 -cpus=&quot;0,2&quot; alpine ## dd if=/dev/zero of=/dev/null &amp; # docker stats # a3의 cpu 사용률 20% 확인 # docker run -itd --name c1 --devie-write-bps /dev/sda:1mb centos # sda 디스크에 write작업시 속도 limit을 1MB/s # docker attach c1 ## dd if=/dev/zero of=/perftest bs=1M count=10 oflag=direct # docker run -itd --name c2 centos # 제한없이 # docker attach c2 ## dd if=/dev/zero of=/perftest bs=1M count=10 oflag=direct . CPU, Memory, Block 제한은 가능하나 NET I/O는 제한 불가 . 워드프레스 컨테이너 실행 example . # docker network create wp-web # 네트워크 생성 # docker run -d --name wp-db --net wp-net -v wp-db-vol:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=1234 -e MYSQL_DATABASE=wordpress -e MYSQL_USER=wordpress -e MYSQL_PASSWORD=1234 mysql:5.7 # docker run -d --name wp-web --net wp-net -v wp-web-vol:/var/www/html --link wp-db:mysql -e WORDPRESS_DB_HOST=wp-db:3306 -e WORDPRESS_DB_PASSWORD=1234 -p 80:80 wordpress . http://localhost:8080 또는 http://localhost:8080/wp-admin/install.php로 확인 . .",
            "url": "https://nueees.github.io/techblog/kubernetes/2021/10/01/Docker-Container-Configuration-management.html",
            "relUrl": "/kubernetes/2021/10/01/Docker-Container-Configuration-management.html",
            "date": " • Oct 1, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "표집분포와 중심극한정리",
            "content": "R과 함께하는 통계학의 이해 - 최용석 . . 5.1 표집분포 . 모수(parameter): 모집단에 대한 수치적 특성값 (모평균, 모비율, 모분산…) . 통계량(statistic): 표본으로부터 획득한 수치적 정보 . 통계량은 그 자체가 하나의 확률변수로서 확률분포를 가지게 된다. . 표집분포(sampling distribution): 통계량이 가지는 확률분포 . 표본 추출과정에서 발생하는 통계량의 값이 가지는 변동은 이 표집분포에 의해 설명될 수 있다. 표집분포는 모집단의 분포에 영향을 받기도 하고 표본의 크기 $n$에도 영향을 받는다. . 확률표본(random sample): 크기가 큰 모집단으로부터 임의 추출된 크기 $n$의 표본 $X_1,X_2,…,X_n$ . $X_1,X_2,…,X_n$은 서로 독립이고 모집단의 분포와 같은 분포를 가진다. . . 5.2 표본평균의 분포와 중심극한정리 . 크기가 $n$인 확률표본 $X_1,X_2,…,X_n$에 대해 $ E(X) = mu $, $ Var(X) = sigma^2 $, $i=1,2,…,n$이고, . $ bar{X} = frac{1}{n} sum{X_i} $일 때, . 표본평균 $ bar{X}$의 기대값과 분산 . $ E( bar{X}) = mu $ $ Var( bar{X}) = frac{ sigma^2}{n} $ . 정규모집단으로부터의 표본평균에 대한 확률분포 . 크기가 $n$인 확률표본 $X_1,X_2,…,X_n$에 대해 $ X_i sim N( mu, sigma^2) $, $i=1,2,…,n$일때, . 표본평균 $ bar{X}$의 확률분포는 $ bar{X} sim N( mu, frac{ sigma^2}{n}) $를 따르게 된다. . 중심극한정리 : 평균이 $ mu$이고 분산이 $ sigma^2$인 모집단으로부터 추출한 크기 $n$의 확률표본의 표본평균 $ bar{X}$는 표본의 크기가 큰 경우(보통 30 이상), 근사적으로 $ mu$이고 분산이 $ frac{ sigma^2}{n}$인 정규분포를 따르게 된다. . .",
            "url": "https://nueees.github.io/techblog/statistics/2021/09/02/%ED%91%9C%EC%A7%91%EB%B6%84%ED%8F%AC%EC%99%80-%EC%A4%91%EC%8B%AC%EA%B7%B9%ED%95%9C%EC%A0%95%EB%A6%AC.html",
            "relUrl": "/statistics/2021/09/02/%ED%91%9C%EC%A7%91%EB%B6%84%ED%8F%AC%EC%99%80-%EC%A4%91%EC%8B%AC%EA%B7%B9%ED%95%9C%EC%A0%95%EB%A6%AC.html",
            "date": " • Sep 2, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "추정",
            "content": "R과 함께하는 통계학의 이해 - 최용석 . . 6.1 통계적 추론 . 통계적 추론(statistical inference): 모집단의 수치적 특성을 나타내는 모수(parameter)에 대한 정보를 얻어내기 위한 일련의 과정 . 통계량(statistic)들의 값을 계산하고 이것을 이용하여 모집단의 특성(모수)를 알아보는 것이다. . 1) 추정(estimation): 모수에 대한 추측값을 얻되, 그 값의 정밀도를 함께 구하는 것 . 2) 가설 검정(hypotheses testing): 표본의 자료가 모수의 참값에 대한 조사자의 추측을 뒷받침하는지 혹은 반증하는지 결정하는 것 -&gt; 7장 . . 6.2 모평균에 대한 점추정 . 점추정: 모수의 참값과 유사할 것이라고 예상되는 하나의 값 제시 . 모집단의 크기가 $n$인 표본을 임의로 추출할 때 이를 $n$개의 확률변수 $X_1,X_2,…,X_n$으로 표현 추정하고자 하는 하나의 모수에 대하여 이들 $n$개의 확률변수를 이용하여 하나의 통계량을 만들고, 나아가 주어진 표본으로부터 그 실제값을 계산하여 하나의 수치를 제시하는 것 . 추정량(estimator): 모수를 추정하기 위해 만들어진 통계량 (ex. $ hat{ mu}, hat{ sigma} $) . 추정치(estimate): 주어진 표본으로부터 계산된 추정량의 실제값 . $ hat{ mu} = bar{X} = frac{1}{n}(X_1+X_2+…+X_n) = frac{1}{n} sum{X_i}$ . 여기서 $ hat{ mu}$는 모평균 $ mu$에 대한 추정량 . 이러한 추정량은 확률변수들로부터 만들어진 하나의 확률변수이므로 추출된 표본의 값에 따라 그 값(추정치)가 달라질 수 있다. . 표준오차(standard error, S.E.): 수치(추정치)들의 변동은 추정량의 정확도와 관계가 있는데, 이 정확도를 측정하기 위해 추정량의 표준편차를 계산한 것 . $ E( bar{X}) = mu , quad S.E.( bar{X}) = frac{ sigma}{ sqrt{n}} $ 따라서 표본평균 $ bar{X} $를 이용하여 모평균 $ mu$를 추정하고자 할 경우 표본의 크기 $n$이 클수록 표준오차가 작아져서 보다 정확한 추정이 가능하다. 하지만 모수인 $ sigma $(모집단의 표준편차)를 모르는 경우 계산할 수 없다. 표본의 표준편차 $ hat{ sigma} $를 이용하여 추정할 수 있다. . $ hat{ sigma} = s = sqrt{ frac{1}{n-1} sum{(X_i- bar{X})^2} } $ . 소나무 성장 연구를 위한 1년생 소나무 묘목 40그루의 크기를 조사한 자료 : 2.6, 1.9, 1.8, 1.6, 1.4, 2.2,…,1.2 전체 1년생 소나무 묘목의 평균 크기에 대한 추정치(= 표본평균($ bar{x}$)) 와 표준오차($ frac{s}{ sqrt{n}}$) : $ bar{x} = frac{1}{40} times (2.6+1.9+…+1.2) = 1.715 $ $ s^2 = frac{1}{40-1} times { (2.6 - 1.715)^2 + … + (1.2-1.715)^2 } = 0.2254 $ $ frac{s}{ sqrt{n}} = frac{ sqrt{0.2254} } { sqrt{40}} = 0.0751 $ | . . 6.3 모평균에 대한 구간추정 . 구간추정: 모수의 참값을 포함할 것으로 예상되는 적절한 구간을 제시 . . 6.4 모비율에 대한 추정 . .",
            "url": "https://nueees.github.io/techblog/statistics/2021/09/02/%EC%B6%94%EC%A0%95.html",
            "relUrl": "/statistics/2021/09/02/%EC%B6%94%EC%A0%95.html",
            "date": " • Sep 2, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "이산확률변수 및 분포",
            "content": "R과 함께하는 통계학의 이해 - 최용석 . . 3.1 사건의 확률 . 확률(probability) : 실험의 결과에 대해 확신하는 정도를 수치적으로 나타는 척도 . 사건(event) : 어떤 특성을 갖는 결과들의 집합을 ($A$, $B$, …) . P(A)=frac사건A에속하는결과수표본공간에속하는결과수P(A) = frac{사건A에 속하는결과 수}{표본공간에 속하는 결과 수}P(A)=frac사건A에속하는결과수표본공간에속하는결과수 . . 3.2. 확률변수 . 확률변수(random variable) : 표본공간에 속하는 각각의 결과들에 대해 실수값 대응 시켜준 변수 ($X$, $Y$, …) . 한주에 경기 수 (0회, 1회, 2회) | . 확률변수가 가지는 특정값 : ($x$, $y$, …) . 가질 수 있는 값에 따라, . 1) 이산확률변수(discrete random variable) 2) 연속확률변수(continuous random variable) . . 3.3 이산확률변수의 확률분포함수 . 확률분포(probability distribution) : 확률변수가 가지는 값과 그 값을 가질 확률을 정해주는 규칙 . 한주의 경기 수와 그 비율 (0회: $ frac{2}{10}$, 1회: $ frac{5}{10}$, 2회: $ frac{3}{10}$) | . (이산확률변수의) 확률분포함수(probability distribution function) : . $ f(x)= P(X=x) $ . 이산 확률분포함수의 성질 . 모든 $x$값에 대해 $0 leq f(x) leq 1$ $ sum f(x) =1 $ . . 3.4 확률변수의 기대값과 표준편차 . 확률변수의 기대값(expected value) : 확률변수가 가질 수 있는 값들에 대한 확률분포 상의 중심위치 . $ E(X) = sum xf(x)$ . 평균적으로 한주에 수행하는 경기 수 ($ 0회 times frac{2}{10} + 1회 times frac{5}{10} + 2회 times frac{3}{10} = 1.1회$ ) | . 평균과 다른 점? 기대값은 동일한 실험을 무수히 반복했을 때의 평균을 의미하고 10회 던져서 8번 나왔다고 0.8이라고 하지 않음 실수값을 갖는 확률변수에 대해서, 모평균은 확률변수의 기대값이 된다. . 기대값의 성질 . $ E(X) = mu $ $ E(a) = a $ $ E(aX) = a mu $ $ E(aX pm b) = a mu pm b$ . 확률변수의 분산(variance) . 평균적으로 한주에 수행하는 경기 수의 분산 ($ (0회-1.1회)^2 times frac{2}{10} + (1회-1.1회)^2 times frac{5}{10} + (2회-1.1회)^2 times frac{3}{10} = 0.49 $ ) | . $ Var(X) = sum (x- mu)^2f(x)$ . $ Var(X) = E[ (X - E(X) )^2 ] $ $ Var(X) = E(X^2) - E(X)^2 $ . . 분산의 성질 . $ Var(X) = sigma^2 $ $ Var(a) = 0 $ $ Var(aX) = a^2 sigma^2 $ $ Var(aX pm b) = a^2 sigma^2 $ . 확률변수의 표준편차(standard deviation) . $ sqrt{ Var(X) } = sqrt{ sum (x- mu)^2f(x) } $ . . 3.5 이항분포 . 3.3에서 확률분포란 확률변수가 가지는 값과 그 값을 가질 확률을 정해주는 규칙이라고 정의하였는데, 규칙이 밝혀져 이름이 부여된 것들이 있는데 대표적인 예가 이항분포 . 베르누이 시행 : 단 1회의 실험 지칭 . 베르누이 시행의 특징 . 각 시행은 성공(success, $S$ )과 실패(fail, $F$ )의 두 가지 결과만을 갖는다. | 각 시행에서 성공할 확률은 $P(S)$ , 실패할 확률은 $P(F)$ 로 매 시행마다 동일하다. | 각 시행은 상호 독립으로 각각의 시행이 다른 시행의 결과에 영향을 미치지 않는다. | . 성공 확률이 $p$인 베르누이 시행을 $n$번 시행한 경우 성공 횟수를 나타내는 확률변수 $X$의 확률분포함수는 . $ f(x) = P(X=x) = _{n}C_{x}p^x(1-p)^{n-x} , x=0,1,…,n$ . 이항부포의 기대값과 분산 . 성공 횟수를 나타내는 확률변수 $X$가 $X ~ Bin(n,p)$일 때, $ E(X) = np $ $ E(X) = np(1-p) $ . .",
            "url": "https://nueees.github.io/techblog/statistics/2021/09/01/%EC%9D%B4%EC%82%B0%ED%99%95%EB%A5%A0%EB%B3%80%EC%88%98-%EB%B0%8F-%EB%B6%84%ED%8F%AC.html",
            "relUrl": "/statistics/2021/09/01/%EC%9D%B4%EC%82%B0%ED%99%95%EB%A5%A0%EB%B3%80%EC%88%98-%EB%B0%8F-%EB%B6%84%ED%8F%AC.html",
            "date": " • Sep 1, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "확률변수 및 분포",
            "content": "R과 함께하는 통계학의 이해 - 최용석 . . 4.1 연속확률변수의 확률분포함수 . 연속확률변수: 확률변수가 특정 구간의 모든 값을 다 가질 수 있기 때문에 가질 수 있는 값들을 일일이 지칭할 수 없는 확률변수를 의미 . 연속확률분포함수: 확률변수 $X$가 가질 수 있는 특정 구간에서 확률이 어떻게 분포하는가를 나타낼 수 있는 함수 . $X$의 확률분포는 확률의 밀도를 나타내는 확률밀도함수 . 확률밀도함수(probability density function) . 모든 $x$에 대해 $f(x) geq 0 $ | $P(a leq X leq b) = int_{a}^{b}{f(x)dx}$ | $P( infty leq X leq - infty) = int_{ infty}^{- infty}{f(x)dx} = 1$ | . 연속확률변수 $X$가 특정한 값 $x$를 갖게 되는 확률은 0이므로, 구간의 확률을 구할 때는 그 구간의 경계점의 포함 유무는 영향을 받지 않는다. . 연속확률변수의 기대값과 분산 . $ E(X) = int{xf(x)dx} $ $ Var(X) = int{(x- mu)^2f(x)dx} = sigma^2 $ . . 4.2 정규분포 . 정규분포(normal distribution): 좌우대칭의 종모양 곡선 (=Gaussian distribution) . [##_Image | kage@b8vAd6/btrfRDJJxUm/7pnXfXfKX8jcEzS7KAwgl1/img.jpg | alignCenter | width=”100%” data-origin-width=”288” data-origin-height=”257” data-ke-mobilestyle=”widthOrigin” |   |   | _##] | . 정규확률변수 : 종 모양의 확률밀도함수를 가지는 연속형확률변수 X . 정규확률변수의 확률분포에 대한 식은 모집단에 대한 평균 $ mu$와 분산 $ sigma^2$에 의존하므로 $ X sim N( mu, sigma^2) $ 로 표기 . . 4.3 정규분포의 확률계산 . 표준정규분포(standard normal distribution): 평균이 0이고, 분산이 1인 정규분포 . 일반적으로 표준정규분포를 따르는 확률변수는 $Z$로 표현 $ Z sim N(0,1) $이므로 확률변수 $Z$는 평균 $E(Z) = mu_z = 0 $이며, 분산은 $ Var(Z) = sigma_z^2 = 1 $과 같다. . 일반적인 정규분포를 따르는 확률변수 $X$에 대한 확률을 표준정규분포를 따르는 확률변수 $Z$로 변환하는 과정을 표준화(Standardization)라고 한다. . $ frac{X- mu_x}{ sigma_x} $ . . 4.4 이항분포의 정규근사 . . $n$이 증가함에 따라 분포의 형태가 점차 좌우대칭의 종 모양에 가까워짐을 확인할 수 있다. . 이항분포의 정규근사 . 확률변수 $X$가 성공 횟수를 나타내는 이산형 확률변수이고 $X sim Bin(n,p) $일 때, $np$나 $n(1-p)$이 모두 충분히 클 경우(보통 10 이상)에 확률변수 $X$는 근사적으로 다음의 정규 분포를 따르게 된다. $ X sim N(np, np(1-p)) $ . .",
            "url": "https://nueees.github.io/techblog/statistics/2021/09/01/%EC%97%B0%EC%86%8D%ED%99%95%EB%A5%A0%EB%B3%80%EC%88%98-%EB%B0%8F-%EB%B6%84%ED%8F%AC.html",
            "relUrl": "/statistics/2021/09/01/%EC%97%B0%EC%86%8D%ED%99%95%EB%A5%A0%EB%B3%80%EC%88%98-%EB%B0%8F-%EB%B6%84%ED%8F%AC.html",
            "date": " • Sep 1, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "Category",
          "content": "Shelf . Statistics | Kubenetes | Spark | .",
          "url": "https://nueees.github.io/techblog/category/",
          "relUrl": "/category/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "About Me",
          "content": ". Seeeun Cho . @nueees . CONTACT . Phone: | Email: nueees@gmail.com | Linkedin: https://www.linkedin.com/in/nueees/ | . EXPERTISE . Program languages: SQL, Java, Javascript, Python, R | Frameworks: Spring, MDD (Model-Driven Development) | Version control systems: SVN, Git, frism | Workflow Control: Job-PaSS | DBMSs: Oracle, Mysql | OSs: Linux, Windows | ETL Tools: TDS, TeraStream, BXI, Oracle GoldenGate, DataPump | . EXPERIENCE . Junior data engineer &amp; developer, JT savings bank | Mar 2020 - Sep 2021 | Junior database engineer, Serends IT service | Feb 2019 - Feb 2020 | Java full stack developer, Kyobo information and communication | Sep 2017 - Nov 2018 | . .",
          "url": "https://nueees.github.io/techblog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page12": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://nueees.github.io/techblog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}